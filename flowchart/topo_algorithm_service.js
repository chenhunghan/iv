// Generated by CoffeeScript 1.7.1


(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
  var saveAs=saveAs||function(e){"use strict";if("undefined"==typeof navigator||!/MSIE [1-9]\./.test(navigator.userAgent)){var t=e.document,n=function(){return e.URL||e.webkitURL||e},o=t.createElementNS("http://www.w3.org/1999/xhtml","a"),r="download"in o,i=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},a=e.webkitRequestFileSystem,c=e.requestFileSystem||a||e.mozRequestFileSystem,u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},f="application/octet-stream",s=0,d=500,l=function(t){var o=function(){"string"==typeof t?n().revokeObjectURL(t):t.remove()};e.chrome?o():setTimeout(o,d)},v=function(e,t,n){t=[].concat(t);for(var o=t.length;o--;){var r=e["on"+t[o]];if("function"==typeof r)try{r.call(e,n||e)}catch(i){u(i)}}},p=function(e){return/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob(["ï»¿",e],{type:e.type}):e},w=function(t,u,d){d||(t=p(t));var w,y,m,S=this,h=t.type,O=!1,R=function(){v(S,"writestart progress write writeend".split(" "))},b=function(){if((O||!w)&&(w=n().createObjectURL(t)),y)y.location.href=w;else{var o=e.open(w,"_blank");void 0==o&&"undefined"!=typeof safari&&(e.location.href=w)}S.readyState=S.DONE,R(),l(w)},g=function(e){return function(){return S.readyState!==S.DONE?e.apply(this,arguments):void 0}},E={create:!0,exclusive:!1};return S.readyState=S.INIT,u||(u="download"),r?(w=n().createObjectURL(t),o.href=w,o.download=u,void setTimeout(function(){i(o),R(),l(w),S.readyState=S.DONE})):(e.chrome&&h&&h!==f&&(m=t.slice||t.webkitSlice,t=m.call(t,0,t.size,f),O=!0),a&&"download"!==u&&(u+=".download"),(h===f||a)&&(y=e),c?(s+=t.size,void c(e.TEMPORARY,s,g(function(e){e.root.getDirectory("saved",E,g(function(e){var n=function(){e.getFile(u,E,g(function(e){e.createWriter(g(function(n){n.onwriteend=function(t){y.location.href=e.toURL(),S.readyState=S.DONE,v(S,"writeend",t),l(e)},n.onerror=function(){var e=n.error;e.code!==e.ABORT_ERR&&b()},"writestart progress write abort".split(" ").forEach(function(e){n["on"+e]=S["on"+e]}),n.write(t),S.abort=function(){n.abort(),S.readyState=S.DONE},S.readyState=S.WRITING}),b)}),b)};e.getFile(u,{create:!1},g(function(e){e.remove(),n()}),g(function(e){e.code===e.NOT_FOUND_ERR?n():b()}))}),b)}),b)):void b())},y=w.prototype,m=function(e,t,n){return new w(e,t,n)};return"undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob?function(e,t,n){return n||(e=p(e)),navigator.msSaveOrOpenBlob(e,t||"download")}:(y.abort=function(){var e=this;e.readyState=e.DONE,v(e,"abort")},y.readyState=y.INIT=0,y.WRITING=1,y.DONE=2,y.error=y.onwritestart=y.onprogress=y.onwrite=y.onabort=y.onerror=y.onwriteend=null,m)}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this.content);"undefined"!=typeof module&&module.exports?module.exports.saveAs=saveAs:"undefined"!=typeof define&&null!==define&&null!=define.amd&&define([],function(){return saveAs});
  angular.module("topo", []).factory("d3", [
    function() {
      return d3;
    }
  ]).factory("topoAlgorithm", [
    "d3", "flowchartDataModel", function(d3, flowchartDataModel) {
      return {
        preProcess: function(raw, cb, mode) {
          var add_to_linkset, blkports, d, data, enhanced_equlink, final, find_dup_n, find_linkidx, find_node_idx, glinks, gnodes, grings, i, l, link, linkidx, links, mring, n, n0, n1, node, omit_dup, p, r, rid, ring, rlinkidx, rnode, upports, _fn, _i, _j, _k, _l, _len, _len1, _len10, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _s;
          grings = {};
          gnodes = [];
          glinks = [];
          find_node_idx = function(mac) {
            var i, node, _i, _len;
            for (i = _i = 0, _len = gnodes.length; _i < _len; i = ++_i) {
              node = gnodes[i];
              if (node.mac === mac) {
                return i;
              }
            }
            return -1;
          };
          add_to_linkset = function(linkset, link) {
            var duplinks, l;
            duplinks = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = linkset.length; _i < _len; _i++) {
                l = linkset[_i];
                if (enhanced_equlink(link, l)) {
                  _results.push(l);
                }
              }
              return _results;
            })();
            if (duplinks.length === 0) {
              return linkset.push(link);
            }
          };
          n0 = -1;
          n1 = -1;
          omit_dup = function(linkset) {
            var j, _i, _len, _results;
            if ((linkset != null) && linkset !== []) {
              _results = [];
              for (_i = 0, _len = linkset.length; _i < _len; _i++) {
                j = linkset[_i];
                _results.push((function(j) {
                  var n;
                  if ((j != null) && (j.nodepair != null) && j.blocked === false) {
                    if ((j.nodepair[0] === n0 && j.nodepair[1] === n1) || (j.nodepair[0] === n1 && j.nodepair[1] === n0) === true) {
                      n = linkset.indexOf(j);
                      linkset.splice(n, 1);
                      return console.log('duplicated data of link is deleted');
                    }
                  }
                })(j));
              }
              return _results;
            }
          };
          find_dup_n = function(linkset) {
            var i, _i, _len, _results;
            if ((linkset != null) && linkset !== []) {
              _results = [];
              for (_i = 0, _len = linkset.length; _i < _len; _i++) {
                i = linkset[_i];
                _results.push((function(i) {
                  if ((i != null) && (i.blocked != null) && i.blocked === true) {
                    n0 = i.nodepair[0];
                    n1 = i.nodepair[1];
                    return omit_dup(linkset);
                  }
                })(i));
              }
              return _results;
            }
          };
          find_linkidx = function(mac, pno) {
            var i, l, nidx, _i, _len;
            nidx = find_node_idx(mac);
            for (i = _i = 0, _len = glinks.length; _i < _len; i = ++_i) {
              l = glinks[i];
              if ((nidx === l.nodepair[0] && pno === l.portpair[0]) || (nidx === l.nodepair[1] && pno === l.portpair[1])) {
                return i;
              }
            }
          };
          enhanced_equlink = function(lka, lkb) {
            return (lka.nodepair[0] === lkb.nodepair[0] && lka.nodepair[1] === lkb.nodepair[1] && lka.blocked === lkb.blocked) || (lka.nodepair[0] === lkb.nodepair[1] && lka.nodepair[1] === lkb.nodepair[0] && lka.blocked === lkb.blocked);
          };
          _fn = function(d) {
            var o;
            if (d.node != null) {
              o = {
                mac: d.node.local_id,
                ip: d.node.local_ip_address,
                location: d.node.sys_location,
                name: d.node.sys_name,
                rings: []
              };
              return gnodes.push(o);
            }
          };
          for (_i = 0, _len = raw.length; _i < _len; _i++) {
            d = raw[_i];
            _fn(d);
          }
          for (_j = 0, _len1 = raw.length; _j < _len1; _j++) {
            d = raw[_j];
            blkports = [];
            upports = [];
            if (d.ports != null) {
              blkports = (function() {
                var _k, _len2, _ref, _results;
                _ref = d.ports;
                _results = [];
                for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                  p = _ref[_k];
                  if (p.blocking) {
                    _results.push(p.no);
                  }
                }
                return _results;
              })();
              upports = (function() {
                var _k, _len2, _ref, _results;
                _ref = d.ports;
                _results = [];
                for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                  p = _ref[_k];
                  if (p.link === 'up') {
                    _results.push(p.no);
                  }
                }
                return _results;
              })();
            }
            if (d.links != null) {
              _ref = d.links;
              for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                l = _ref[_k];
                if (_ref1 = l.local_port_no, __indexOf.call(upports, _ref1) < 0) {
                  continue;
                }
                if (find_node_idx(l.neighbour_id) < 0) {
                  gnodes.push({
                    mac: l.neighbour_id,
                    ip: l.neighbour_ip_address,
                    location: 'unknown',
                    name: l.neighbour_system_name
                  });
                }
                link = {
                  nodepair: [find_node_idx(l.local_id), find_node_idx(l.neighbour_id)],
                  portpair: [l.local_port_no, l.neighbour_port_no],
                  blocked: (_ref2 = l.local_port_no, __indexOf.call(blkports, _ref2) >= 0)
                };
                add_to_linkset(glinks, link);
                find_dup_n(glinks);
              }
            }
          }
          for (_l = 0, _len3 = raw.length; _l < _len3; _l++) {
            d = raw[_l];
            if (d.rings == null) {
              continue;
            }
            _ref3 = d.rings;
            for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
              r = _ref3[_m];
              if (grings[r.ring_id] == null) {
                grings[r.ring_id] = {
                  id: r.ring_id,
                  type: r.type,
                  state: r.state,
                  nodes: [],
                  links: []
                };
              }
              mring = grings[r.ring_id];
              if (d.node != null) {
                mring.nodes.push({
                  idx: find_node_idx(d.node.local_id),
                  role: r.role
                });
              }
              if (d.node != null) {
                linkidx = find_linkidx(d.node.local_id, r.ring_port_0);
              }
              if (linkidx != null) {
                if (__indexOf.call(mring.links, linkidx) < 0) {
                  mring.links.push(linkidx);
                }
              }
              if (d.node != null) {
                linkidx = find_linkidx(d.node.local_id, r.ring_port_1);
              }
              if (linkidx != null) {
                if (__indexOf.call(mring.links, linkidx) < 0) {
                  mring.links.push(linkidx);
                }
              }
            }
          }
          for (rid in grings) {
            ring = grings[rid];
            _ref4 = ring.nodes;
            for (_n = 0, _len5 = _ref4.length; _n < _len5; _n++) {
              rnode = _ref4[_n];
              node = gnodes[rnode.idx];
              node.rings.push({
                id: ring.id,
                type: ring.type,
                role: rnode.role
              });
            }
            _ref5 = ring.links;
            for (_o = 0, _len6 = _ref5.length; _o < _len6; _o++) {
              rlinkidx = _ref5[_o];
              link = glinks[rlinkidx];
              if (link.rings == null) {
                link.rings = [];
              }
              link.rings.push({
                id: ring.id,
                type: ring.type
              });
            }
          }
          links = [];
          for (i = _p = 0, _len7 = gnodes.length; _p < _len7; i = ++_p) {
            n = gnodes[i];
            n.id = i;
            n.inputConnectors = [];
            n.outputConnectors = [];
          }
          for (_q = 0, _len8 = glinks.length; _q < _len8; _q++) {
            l = glinks[_q];
            links.push({
              source: gnodes[l.nodepair[0]],
              target: gnodes[l.nodepair[1]],
              dest: {},
              sourceport: l.portpair[0],
              targetport: l.portpair[1]
            });
          }
          final = {
            nodes: gnodes,
            rings: grings
          };
          final.links = links;
          data = {};
          _ref6 = final.links;
          for (_r = 0, _len9 = _ref6.length; _r < _len9; _r++) {
            link = _ref6[_r];
            if (link.sourceport > 6) {
              final.nodes[final.nodes.indexOf(link.source)].outputConnectors.push({
                name: link.sourceport
              });
            }
            if (link.sourceport < 6 || link.sourceport === 6) {
              final.nodes[final.nodes.indexOf(link.source)].inputConnectors.push({
                name: link.sourceport
              });
            }
            if (link.targetport > 6) {
              final.nodes[final.nodes.indexOf(link.target)].outputConnectors.push({
                name: link.targetport
              });
            }
            if (link.targetport < 6 || link.targetport === 6) {
              final.nodes[final.nodes.indexOf(link.target)].inputConnectors.push({
                name: link.targetport
              });
            }
          }
          _ref7 = final.links;
          for (_s = 0, _len10 = _ref7.length; _s < _len10; _s++) {
            link = _ref7[_s];
            link.source.nodeID = link.source.id;
            link.dest.nodeID = link.target.id;
          }
          data.nodes = final.nodes;
          data.connections = final.links;




          if (mode === 'noPos') {
            return cb(data);
          } else {
            return this.processPosdata(data, cb);
          }
          var json = new Blob([JSON.stringify(data)], {type:"application/json"})
          saveAs(json, "nodesAndLinks.json")

        },
        processPosdata: function(data, cb) {
          var did_not_call, force, height, i, n, that, width;
          that = this;
          did_not_call = true;
          width = flowchartDataModel.width;
          height = flowchartDataModel.height;
          force = d3.layout.force().nodes(data.nodes).links(data.connections).charge(-4800).linkDistance(120).size([width, height]).gravity(0.25).on('tick', function(a) {
            if (a.alpha < 0.0367 && did_not_call === true) {
              did_not_call = false;
              force.nodes().forEach(function(o, i) {
                o.x = o.x * 1.5 - 350;
                return o.y = o.y * 0.6 + 30;
              });
              force.nodes().forEach(function(o, i) {
                if (o.x < 30) {
                  o.x = 50;
                }
                if (o.x > (width - 250)) {
                  o.x = width - 250;
                }
                if (o.y < 30) {
                  o.y = 50;
                }
                if (o.y > (height - 150)) {
                  return o.y = height - 150;
                }
              });
              that.finalize(force.nodes(), force.links(), cb);
              //var data = {}
              //data.nodes = force.nodes()
              //data.links = force.links()
              //var json = new Blob([JSON.stringify(data)], {type:"application/json"})
              //saveAs(json, "nodesAndLinksWithPos.json")

              return force.stop();
            }
          });
          n = 100;
          force.start();
          i = 0;
          while (i < n) {
            force.tick();
            ++i;
          }
          return force.stop();
        },
        finalize: function(nodes_w_pos, links_w_pos, cb) {
          var data;
          data = {
            nodes: nodes_w_pos,
            connections: links_w_pos
          };
          return cb(data);
        }
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=topo_algorithm_service.map
