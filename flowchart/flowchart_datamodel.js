// Generated by CoffeeScript 1.7.1
(function() {
  var debug;

  if (typeof debug !== "undefined") {
    throw new Error("debug object already defined!");
  }

  debug = {};

  debug.assertObjectValid = function(obj) {
    if (!obj) {
      throw new Exception("Invalid object!");
    }
    if ($.isPlainObject(obj)) {
      throw new Error("Input is not an object! It is a " + typeof obj);
    }
  };

  angular.module("flowchartDataModel", []).service("node", [
    function() {
      var node;
      node = this;
      node.width = 60;
      node.padding = 15;
      node.nodeNameHeight = 50;
    }
  ]).service("connector", [
    "node", function(node) {
      var connector;
      connector = this;
      connector.connectorHeight = 46;
      connector.ConnectorViewModel = function(connectorDataModel, x, y, parentNode) {
        if (x === 0) {
          x = x + node.padding;
        } else {
          x = x - node.padding;
        }
        this.data = connectorDataModel;
        this.data.linked = true;
        this.linked = function() {
          return this.data.linked;
        };
        this._parentNode = parentNode;
        this._x = x;
        this._y = y;
        this.name = function() {
          return this.data.name;
        };
        this.x = function() {
          return this._x;
        };
        this.y = function() {
          return this._y;
        };
        this.parentNode = function() {
          return this._parentNode;
        };
      };
    }
  ]).service("flowchartDataModel", [
    "node", "connector", function(node, connector) {
      var computeConnectionTangentOffset, createNodesViewModel, flowchart;
      flowchart = this;
      flowchart.width = 1185;
      flowchart.height = 580;
      flowchart.nodeWidth = node.width;
      flowchart.padding = node.padding;
      flowchart.nodeNameHeight = node.nodeNameHeight;
      flowchart.connectorHeight = connector.connectorHeight;
      flowchart.computeConnectorY = function(connectorIndex) {
        return flowchart.nodeNameHeight + (connectorIndex * flowchart.connectorHeight);
      };
      flowchart.computeConnectorPos = function(node, connectorIndex, inputConnector) {
        return {
          x: node.x() + (inputConnector ? flowchart.padding : flowchart.nodeWidth - flowchart.padding),
          y: node.y() + flowchart.computeConnectorY(connectorIndex)
        };
      };
      flowchart.NodeViewModel = function(nodeDataModel) {
        var createConnectorsViewModel;
        createConnectorsViewModel = function(connectorDataModels, x, parentNode) {
          var connectorViewModel, i, viewModels;
          viewModels = [];
          if (connectorDataModels) {
            i = 0;
            while (i < connectorDataModels.length) {
              connectorViewModel = new connector.ConnectorViewModel(connectorDataModels[i], x, flowchart.computeConnectorY(i), parentNode);
              viewModels.push(connectorViewModel);
              ++i;
            }
          }
          return viewModels;
        };
        this.data = nodeDataModel;
        this.inputConnectors = createConnectorsViewModel(this.data.inputConnectors, 0, this);
        this.outputConnectors = createConnectorsViewModel(this.data.outputConnectors, flowchart.nodeWidth, this);
        this._selected = false;
        this.data.nodeAlive = true;
        this.data.nodeWarning = false;
        this.name = function() {
          return this.data.name || "";
        };
        this.x = function() {
          return this.data.x;
        };
        this.y = function() {
          return this.data.y;
        };
        this.width = function() {
          return flowchart.nodeWidth;
        };
        this.height = function() {
          var numConnectors;
          numConnectors = Math.max(this.inputConnectors.length, this.outputConnectors.length);
          return flowchart.computeConnectorY(numConnectors) - 25;
        };
        this.select = function() {
          this._selected = true;
        };
        this.deselect = function() {
          this._selected = false;
        };
        this.toggleSelected = function() {
          this._selected = !this._selected;
        };
        this.selected = function() {
          return this._selected;
        };
        this.nodeAlive = function() {
          return this.data.nodeAlive;
        };
        this.nodeWarning = function() {
          return this.data.nodeWarning;
        };
        this._addConnector = function(connectorDataModel, x, connectorsDataModel, connectorsViewModel) {
          var connectorViewModel;
          connectorViewModel = new connector.ConnectorViewModel(connectorDataModel, x, flowchart.computeConnectorY(connectorsViewModel.length), this);
          connectorsDataModel.push(connectorDataModel);
          connectorsViewModel.push(connectorViewModel);
        };
        this.addInputConnector = function(connectorDataModel) {
          if (!this.data.inputConnectors) {
            this.data.inputConnectors = [];
          }
          this._addConnector(connectorDataModel, 0, this.data.inputConnectors, this.inputConnectors);
        };
        this.addOutputConnector = function(connectorDataModel) {
          if (!this.data.outputConnectors) {
            this.data.outputConnectors = [];
          }
          this._addConnector(connectorDataModel, flowchart.nodeWidth, this.data.outputConnectors, this.outputConnectors);
        };
      };
      createNodesViewModel = function(nodesDataModel) {
        var i, nodesViewModel;
        nodesViewModel = [];
        if (nodesDataModel) {
          i = 0;
          while (i < nodesDataModel.length) {
            nodesViewModel.push(new flowchart.NodeViewModel(nodesDataModel[i]));
            ++i;
          }
        }
        return nodesViewModel;
      };
      flowchart.ConnectionViewModel = function(connectionDataModel, sourceConnector, destConnector) {
        this.data = connectionDataModel;
        this.source = sourceConnector;
        this.dest = destConnector;
        this._selected = false;
        this.sourceCoordX = function() {
          if (this.source) {
            return this.source.parentNode().x() + this.source.x();
          }
        };
        this.sourceCoordY = function() {
          if (this.source) {
            return this.source.parentNode().y() + this.source.y();
          }
        };
        this.sourceCoord = function() {
          return {
            x: this.sourceCoordX(),
            y: this.sourceCoordY()
          };
        };
        this.sourceTangentX = function() {
          return flowchart.computeConnectionSourceTangentX(this.sourceCoord(), this.destCoord());
        };
        this.sourceTangentY = function() {
          return flowchart.computeConnectionSourceTangentY(this.sourceCoord(), this.destCoord());
        };
        this.destCoordX = function() {
          if (this.dest) {
            return this.dest.parentNode().x() + this.dest.x();
          }
        };
        this.destCoordY = function() {
          if (this.dest) {
            return this.dest.parentNode().y() + this.dest.y();
          }
        };
        this.destCoord = function() {
          return {
            x: this.destCoordX(),
            y: this.destCoordY()
          };
        };
        this.destTangentX = function() {
          return flowchart.computeConnectionDestTangentX(this.sourceCoord(), this.destCoord());
        };
        this.destTangentY = function() {
          return flowchart.computeConnectionDestTangentY(this.sourceCoord(), this.destCoord());
        };
        this.distance = function() {
          var dd, dx, dy;
          dd = function(a) {
            return a * a;
          };
          dx = this.destCoordX() - this.sourceCoordX();
          dy = this.destCoordY() - this.sourceCoordY();
          return Math.sqrt(dd(dx) + dd(dy));
        };
        this.opacity = 0.2;
        this.select = function() {
          this._selected = true;
        };
        this.deselect = function() {
          this._selected = false;
        };
        this.toggleSelected = function() {
          this._selected = !this._selected;
        };
        this.selected = function() {
          return this._selected;
        };
        this.data.connectionAlive = true;
        this.data.connectionNotBlocked = true;
        this.connectionAlive = function() {
          return this.data.connectionAlive;
        };
        this.connectionNotBlocked = function() {
          return this.data.connectionNotBlocked;
        };
      };
      computeConnectionTangentOffset = function(pt1, pt2) {
        return (pt2.x - pt1.x) / 2;
      };
      flowchart.computeConnectionSourceTangentX = function(pt1, pt2) {
        return pt1.x + computeConnectionTangentOffset(pt1, pt2);
      };
      flowchart.computeConnectionSourceTangentY = function(pt1, pt2) {
        return pt1.y;
      };
      flowchart.computeConnectionSourceTangent = function(pt1, pt2) {
        return {
          x: flowchart.computeConnectionSourceTangentX(pt1, pt2),
          y: flowchart.computeConnectionSourceTangentY(pt1, pt2)
        };
      };
      flowchart.computeConnectionDestTangentX = function(pt1, pt2) {
        return pt2.x - computeConnectionTangentOffset(pt1, pt2);
      };
      flowchart.computeConnectionDestTangentY = function(pt1, pt2) {
        return pt2.y;
      };
      flowchart.computeConnectionDestTangent = function(pt1, pt2) {
        return {
          x: flowchart.computeConnectionDestTangentX(pt1, pt2),
          y: flowchart.computeConnectionDestTangentY(pt1, pt2)
        };
      };
      flowchart.ChartViewModel = function(chartDataModel) {
        this.width = flowchart.width;
        this.height = flowchart.height;
        this.findNode = function(nodeID) {
          var i;
          i = 0;
          while (i < this.nodes.length) {
            node = this.nodes[i];
            if (node.data.id === nodeID) {
              return node;
            }
            ++i;
          }
          throw new Error("Failed to find node " + nodeID);
          return false;
        };
        this.findConnector = function(nodeID, connectorIndex) {
          var i, j, n, nin, nout;
          node = this.findNode(nodeID);
          i = 0;
          while (i < node.inputConnectors.length) {
            nin = node.inputConnectors[i];
            if (nin.data.name === connectorIndex) {
              n = nin;
              i = node.inputConnectors.length;
            } else {
              i++;
            }
          }
          j = 0;
          while (j < node.outputConnectors.length) {
            nout = node.outputConnectors[j];
            if (nout.data.name === connectorIndex) {
              n = nout;
              j = node.outputConnectors.length;
            } else {
              j++;
            }
          }
          return n;
        };
        this.findNodeByIP = function(nodeIP) {
          var i;
          i = 0;
          while (i < this.nodes.length) {
            node = this.nodes[i];
            if (node.data.ip === nodeIP) {
              return node;
            }
            ++i;
          }
          return false;
        };
        this._createConnectionViewModel = function(connectionDataModel) {
          var destConnector, sourceConnector;
          sourceConnector = this.findConnector(connectionDataModel.source.nodeID, connectionDataModel.sourceport);
          destConnector = this.findConnector(connectionDataModel.dest.nodeID, connectionDataModel.targetport);
          return new flowchart.ConnectionViewModel(connectionDataModel, sourceConnector, destConnector);
        };
        this._createConnectionsViewModel = function(connectionsDataModel) {
          var connectionsViewModel, i;
          connectionsViewModel = [];
          if (connectionsDataModel) {
            i = 0;
            while (i < connectionsDataModel.length) {
              connectionsViewModel.push(this._createConnectionViewModel(connectionsDataModel[i]));
              ++i;
            }
          }
          return connectionsViewModel;
        };
        this.data = chartDataModel;
        this.nodes = createNodesViewModel(this.data.nodes);
        this.connections = this._createConnectionsViewModel(this.data.connections);
        this.createNewConnection = function(sourceConnector, destConnector) {
          var connectionDataModel, connectionViewModel, connectionsDataModel, connectionsViewModel, destConnectorIndex, destNode, sourceConnectorIndex, sourceNode;
          debug.assertObjectValid(sourceConnector);
          debug.assertObjectValid(destConnector);
          connectionsDataModel = this.data.connections;
          if (!connectionsDataModel) {
            connectionsDataModel = this.data.connections = [];
          }
          connectionsViewModel = this.connections;
          if (!connectionsViewModel) {
            connectionsViewModel = this.connections = [];
          }
          sourceNode = sourceConnector.parentNode();
          sourceConnectorIndex = sourceNode.outputConnectors.indexOf(sourceConnector);
          if (sourceConnectorIndex === -1) {
            sourceConnectorIndex = sourceNode.inputConnectors.indexOf(sourceConnector);
            if (sourceConnectorIndex === -1) {
              throw new Error("Failed to find source connector within either inputConnectors or outputConnectors of source node.");
            }
          }
          destNode = destConnector.parentNode();
          destConnectorIndex = destNode.inputConnectors.indexOf(destConnector);
          if (destConnectorIndex === -1) {
            destConnectorIndex = destNode.outputConnectors.indexOf(destConnector);
            if (destConnectorIndex === -1) {
              throw new Error("Failed to find dest connector within inputConnectors or ouputConnectors of dest node.");
            }
          }
          connectionDataModel = {
            source: {
              nodeID: sourceNode.data.id,
              connectorIndex: sourceConnectorIndex
            },
            dest: {
              nodeID: destNode.data.id,
              connectorIndex: destConnectorIndex
            }
          };
          connectionsDataModel.push(connectionDataModel);
          connectionViewModel = new flowchart.ConnectionViewModel(connectionDataModel, sourceConnector, destConnector);
          connectionsViewModel.push(connectionViewModel);
        };
        this.addNode = function(nodeDataModel) {
          if (!this.data.nodes) {
            this.data.nodes = [];
          }
          this.data.nodes.push(nodeDataModel);
          this.nodes.push(new flowchart.NodeViewModel(nodeDataModel));
        };
        this.selectAll = function() {
          var connection, connections, i, nodes;
          nodes = this.nodes;
          i = 0;
          while (i < nodes.length) {
            node = nodes[i];
            node.select();
            ++i;
          }
          connections = this.connections;
          i = 0;
          while (i < connections.length) {
            connection = connections[i];
            connection.select();
            ++i;
          }
        };
        this.deselectAll = function() {
          var connection, connections, i, nodes;
          nodes = this.nodes;
          i = 0;
          while (i < nodes.length) {
            node = nodes[i];
            node.deselect();
            ++i;
          }
          connections = this.connections;
          i = 0;
          while (i < connections.length) {
            connection = connections[i];
            connection.deselect();
            ++i;
          }
        };
        this.updateSelectedNodesLocation = function(deltaX, deltaY) {
          var i, selectedNodes;
          selectedNodes = this.getSelectedNodes();
          i = 0;
          while (i < selectedNodes.length) {
            node = selectedNodes[i];
            node.data.x += deltaX;
            node.data.y += deltaY;
            ++i;
          }
        };
        this.handleNodeClicked = function(node, evt) {
          var nodeIndex;
          if (evt) {
            node.toggleSelected();
          } else {
            this.deselectAll();
            node.select();
          }
          nodeIndex = this.nodes.indexOf(node);
          if (nodeIndex === -1) {
            throw new Error("Failed to find node in view model!");
          }
          this.nodes.splice(nodeIndex, 1);
          this.nodes.push(node);
        };
        this.handleConnectionMouseDown = function(connection, ctrlKey) {
          if (ctrlKey) {
            connection.toggleSelected();
          } else {
            this.deselectAll();
            connection.select();
          }
        };
        this.deleteSelected = function() {
          var connection, connectionIndex, deletedNodeIds, newConnectionDataModels, newConnectionViewModels, newNodeDataModels, newNodeViewModels, nodeIndex;
          newNodeViewModels = [];
          newNodeDataModels = [];
          deletedNodeIds = [];
          nodeIndex = 0;
          while (nodeIndex < this.nodes.length) {
            node = this.nodes[nodeIndex];
            if (!node.selected()) {
              newNodeViewModels.push(node);
              newNodeDataModels.push(node.data);
            } else {
              deletedNodeIds.push(node.data.id);
            }
            ++nodeIndex;
          }
          newConnectionViewModels = [];
          newConnectionDataModels = [];
          connectionIndex = 0;
          while (connectionIndex < this.connections.length) {
            connection = this.connections[connectionIndex];
            if (!connection.selected() && deletedNodeIds.indexOf(connection.data.source.nodeID) === -1 && deletedNodeIds.indexOf(connection.data.dest.nodeID) === -1) {
              newConnectionViewModels.push(connection);
              newConnectionDataModels.push(connection.data);
            }
            ++connectionIndex;
          }
          this.nodes = newNodeViewModels;
          this.data.nodes = newNodeDataModels;
          this.connections = newConnectionViewModels;
          this.data.connections = newConnectionDataModels;
        };
        this.updateNodeQuantity = function() {
          var connection, connectionIndex, diff, i, newConnectionDataModels, newConnectionViewModels, newnodeid, oldnodeid;
          oldnodeid = (function() {
            var _i, _len, _ref, _results;
            _ref = this.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              _results.push(node.data.id);
            }
            return _results;
          }).call(this);
          newnodeid = (function() {
            var _i, _len, _ref, _results;
            _ref = this.data.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              _results.push(node.id);
            }
            return _results;
          }).call(this);
          diff = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = oldnodeid.length; _i < _len; _i++) {
              i = oldnodeid[_i];
              if (newnodeid.indexOf(i) === -1) {
                _results.push(i);
              }
            }
            return _results;
          })();
          newConnectionViewModels = [];
          newConnectionDataModels = [];
          connectionIndex = 0;
          while (connectionIndex < this.connections.length) {
            connection = this.connections[connectionIndex];
            if (diff.indexOf(connection.data.source.nodeID) === -1 && diff.indexOf(connection.data.dest.nodeID) === -1) {
              newConnectionViewModels.push(connection);
              newConnectionDataModels.push(connection.data);
            }
            ++connectionIndex;
          }
          this.connections = newConnectionViewModels;
          this.data.connections = newConnectionDataModels;
          return this.nodes = createNodesViewModel(this.data.nodes);
        };
        this.applySelectionRect = function(selectionRect) {
          var connection, i;
          this.deselectAll();
          i = 0;
          while (i < this.nodes.length) {
            node = this.nodes[i];
            if (node.x() >= selectionRect.x && node.y() >= selectionRect.y && node.x() + node.width() <= selectionRect.x + selectionRect.width && node.y() + node.height() <= selectionRect.y + selectionRect.height) {
              node.select();
            }
            ++i;
          }
          i = 0;
          while (i < this.connections.length) {
            connection = this.connections[i];
            if (connection.source.parentNode().selected() && connection.dest.parentNode().selected()) {
              connection.select();
            }
            ++i;
          }
        };
        this.getSelectedNodes = function() {
          var i, selectedNodes;
          selectedNodes = [];
          i = 0;
          while (i < this.nodes.length) {
            node = this.nodes[i];
            if (node.selected()) {
              selectedNodes.push(node);
            }
            ++i;
          }
          return selectedNodes;
        };
        this.getSelectedConnections = function() {
          var connection, i, selectedConnections;
          selectedConnections = [];
          i = 0;
          while (i < this.connections.length) {
            connection = this.connections[i];
            if (connection.selected()) {
              selectedConnections.push(connection);
            }
            ++i;
          }
          return selectedConnections;
        };
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=flowchart_datamodel.map
