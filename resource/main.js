// Generated by CoffeeScript 1.6.3
(function() {
  var gui, ngapp, win,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  gui = require('nw.gui');

  win = gui.Window.get();

  process.on("uncaughtException", function() {
    var err;
    err = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    console.log('node.js error: ');
    return console.log(err);
  });

  ngapp = angular.module('viewerapp', ['rzModule', 'ngAnimate']);

  window.mr = require('./mcast');

  window.targetmac = [''];

  window.fileserver = require('./static_server');

  window.tftp = require('./tftp');

  ngapp.service('smith', function($rootScope, msgbox, effect) {
    window.agent = [];
    window.smith_reconnect = true;
    window.targetip = [];
    window.agent_start = function() {
      var create_agent, ip, _i, _len, _ref, _results;
      create_agent = function(ip) {
        var detect_disconnect, monitor, net, reconnect, serv_port, socket;
        ip = ip;
        net = require("net");
        serv_port = 1337;
        detect_disconnect = function(i) {
          if (i.transport === void 0) {
            return true;
          } else {
            return false;
          }
        };
        monitor = function() {
          socket.on('timeout', function() {
            var msg;
            msg = 'connection with ' + ip + ' is timeout..';
            return msgbox.msgbar_show(msg, 'error');
          });
          socket.on('error', function(e) {
            console.log(e);
            return setTimeout((function() {
              reconnect();
              return ff;
            }), 2000);
          });
          return socket.on('connect', function() {
            var Agent, ag;
            socket.setTimeout(0);
            Agent = require('smith').Agent;
            ag = new Agent();
            ag.connect(socket, function(err, apis) {
              if (err != null) {

              }
            });
            ag.on('connect', function() {
              var test_exist;
              window.agent = _.reject(window.agent, detect_disconnect);
              test_exist = function(i) {
                if (i.transport.input.remoteAddress === ag.transport.input.remoteAddress) {
                  return false;
                } else {
                  return true;
                }
              };
              if (_.every(window.agent, test_exist) === true) {
                window.agent.push(ag);
                msgbox.msgbar_show('sucessfully connected to ' + ip, 'info');
                if ($rootScope.config === void 0) {
                  $rootScope.config = 'network';
                  $rootScope.$apply();
                }
                if (window.agent.length !== 0) {
                  $rootScope.smith_not_connected = false;
                  return $rootScope.$apply();
                }
              }
            });
            return ag.on('disconnect', function(err) {
              if (err !== 'by manaul') {
                msgbox.msgbar_show('temporary disconnect with ' + ip + ' automatocally reconnect in 3 secs..', 'error');
                window.agent = _.reject(window.agent, detect_disconnect);
                return setTimeout((function() {
                  return reconnect();
                }), 3000);
              }
            });
          });
        };
        socket = net.connect(serv_port, ip);
        socket.setTimeout(12000);
        monitor();
        msgbox.msgbar_show('trying to establish connection with ' + ip, 'info');
        return reconnect = function() {
          if (window.smith_reconnect === true) {
            socket = net.connect(serv_port, ip);
            socket.setTimeout(12000);
            msgbox.msgbar_show('trying to reconnect with ' + ip, 'info');
            return monitor();
          }
        };
      };
      _ref = window.targetip;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ip = _ref[_i];
        _results.push((function(ip) {
          return create_agent(ip);
        })(ip));
      }
      return _results;
    };
    return {
      emit: function() {
        var a, api, detect_disconnect, msg, send_get, send_set;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        api = a[0];
        msg = a[1];
        detect_disconnect = function(i) {
          if (i.transport === void 0) {
            return true;
          } else {
            return false;
          }
        };
        send_set = function() {
          var agent, applying_status, _i, _len, _ref, _results;
          applying_status = function(ipip, cls) {
            switch (cls) {
              case 'apply_success':
                d3.select('.lstext' + '.' + ipip).classed('apply_fail', false);
                d3.select('.lstext' + '.' + ipip).classed('same', false);
                d3.select('.lstext' + '.' + ipip).classed('host', false);
                d3.select('.lstext' + '.' + ipip).classed('diff', false);
                return d3.select('.lstext' + '.' + ipip).classed('same', true);
              case 'apply_fail':
                d3.select('.lstext' + '.' + ipip).classed('apply_fail', false);
                d3.select('.lstext' + '.' + ipip).classed('same', false);
                d3.select('.lstext' + '.' + ipip).classed('host', false);
                d3.select('.lstext' + '.' + ipip).classed('diff', false);
                return d3.select('.lstext' + '.' + ipip).classed('apply_fail', true);
            }
          };
          _ref = window.agent;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            agent = _ref[_i];
            _results.push((function(agent) {
              var cb, info, ip, ipip;
              d3.selectAll('.lstext_active').classed('apply_fail', false);
              d3.selectAll('.lstext_active').classed('apply_fail', true);
              if (agent.transport !== void 0) {
                ip = agent.transport.input.remoteAddress;
                ipip = 'IP' + ip.replace(/\./g, '');
                info = 'applying configuration to devices... Please wait...';
                msgbox.msgbar_show(info, 'info');
                cb = function() {
                  if (arguments.length === 0 || arguments[0] === true) {
                    msg = 'apply configuration to ' + ip + ' without errors';
                    msgbox.msgbar_show(msg, 'success');
                    return applying_status(ipip, 'apply_success');
                  } else {
                    if (arguments[0].code != null) {
                      return msgbox.msgbar_show('failed to config. Error code: ' + arguments[0].code, 'error');
                    }
                  }
                };
                a.push(cb);
                agent.send(a);
                console.log(a);
                a.pop();
                return console.log(a);
              } else {
                msg = 'Lost connection. Applying configurations is failed. Please check your connection and apply again.';
                return msgbox.msgbar_show(msg, 'error');
              }
            })(agent));
          }
          return _results;
        };
        send_get = function() {
          var agent, _i, _len, _ref, _results;
          _ref = window.agent;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            agent = _ref[_i];
            _results.push((function(agent) {
              if (agent.transport != null) {
                return agent.send(a);
              } else {

              }
            })(agent));
          }
          return _results;
        };
        if (msg !== void 0 && api !== void 0) {
          if (api.match(/get/g) !== null) {
            send_get();
            return console.log('smith emit get msg...');
          } else {
            if (api.match(/set/g) !== null) {
              send_set();
              return console.log('smith emit set msg...');
            } else {
              console.log('other api');
              return send_get();
            }
          }
        } else {
          if (api === 'system::all_save_cfg') {
            return send_set();
          } else {
            console.log(api);
            console.log(msg);
            return msgbox.msgbar_show('value invalid, please check your input value', 'error');
          }
        }
      }
    };
  });

  ngapp.service('compare', function($rootScope, msgbox) {
    window.config_data = {};
    return {
      init: function() {
        msgbox.msgbar_show('trying to get data from selected devices... please wait', 'info');
        return $rootScope.smith_not_connected = true;
      },
      pushdata: function(agent, api, cfg) {
        var apivalue, ip;
        if (cfg !== void 0 && (agent.transport != null)) {
          msgbox.msgbar_show('received data from devices', 'info');
          $rootScope.smith_not_connected = false;
          $rootScope.$apply();
          ip = agent.transport.input.remoteAddress;
          apivalue = {};
          apivalue[api] = $.extend(apivalue[api], cfg);
          return window.config_data[ip] = $.extend(window.config_data[ip], apivalue);
        } else {

        }
      },
      compare: function(agent, api) {
        var data, host, ip, n, refer, referdata, referobj, _ref, _results;
        if (agent.transport != null) {
          n = _.keys(window.config_data);
          if (n.length > 1) {
            refer = agent.transport.input.remoteAddress;
            referobj = window.config_data[refer];
            referdata = referobj[api];
            host = 'IP' + refer.replace(/\./g, '');
            _ref = window.config_data;
            _results = [];
            for (ip in _ref) {
              data = _ref[ip];
              _results.push((function(ip, data) {
                var other;
                if (ip !== refer) {
                  other = 'IP' + ip.replace(/\./g, '');
                  if (angular.equals(data[api], referdata) === true) {
                    d3.select('.lstext' + '.' + other).classed('apply_fail', false);
                    d3.select('.lstext' + '.' + other).classed('same', false);
                    d3.select('.lstext' + '.' + other).classed('host', false);
                    d3.select('.lstext' + '.' + other).classed('diff', false);
                    d3.select('.lstext' + '.' + other).classed('same', true);
                    d3.select('.lstext' + '.' + host).classed('apply_fail', false);
                    d3.select('.lstext' + '.' + host).classed('host', false);
                    d3.select('.lstext' + '.' + host).classed('same', false);
                    d3.select('.lstext' + '.' + host).classed('diff', false);
                    d3.select('.lstext' + '.' + host).classed('host', true);
                  }
                  if (angular.equals(data[api], referdata) === false) {
                    d3.select('.lstext' + '.' + other).classed('apply_fail', false);
                    d3.select('.lstext' + '.' + other).classed('same', false);
                    d3.select('.lstext' + '.' + other).classed('host', false);
                    d3.select('.lstext' + '.' + other).classed('diff', false);
                    d3.select('.lstext' + '.' + other).classed('diff', true);
                    d3.select('.lstext' + '.' + host).classed('apply_fail', false);
                    d3.select('.lstext' + '.' + host).classed('host', false);
                    d3.select('.lstext' + '.' + host).classed('same', false);
                    d3.select('.lstext' + '.' + host).classed('diff', false);
                    return d3.select('.lstext' + '.' + host).classed('host', true);
                  }
                }
              })(ip, data));
            }
            return _results;
          }
        } else {

        }
      }
    };
  });

  ngapp.service('effect', function($rootScope) {
    return {
      animated: function(element_id, animation_name) {
        $(element_id).addClass("animated " + animation_name);
        return $(element_id).on("webkitAnimationEnd", function() {
          return $(element_id).removeClass("animated " + animation_name);
        });
      },
      show_spinner: function() {
        var arg;
        arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        $rootScope.content = arg[0];
        $rootScope.duration = arg[1];
        $rootScope.show_global_loading = true;
        switch ($rootScope.content) {
          case 'Applying':
            d3.select('.spinning_msg');
            break;
          case 'Scanning':
            d3.select('.spinning_msg');
            break;
          default:
            d3.select('.spinning_msg').text;
        }
        if (($rootScope.duration != null) && $rootScope.duration > 0) {
          return $timeout((function() {
            return $rootScope.show_global_loading = false;
          }), $rootScope.duration);
        }
      },
      hide_spinner: function() {
        return $rootScope.show_global_loading = false;
      }
    };
  });

  ngapp.service('topo', function($rootScope, $q, msgbox, effect) {
    return {
      showd3: function() {
        var add_apply_ip_button, add_backto_setip_btn, add_backward_to_selection, add_cancel_apply_ip_button, add_ip_panel, add_ip_panel_items, add_panel_controller, add_select_btn_group, add_set_ip_button, add_show_detail_panel, add_validate, adjust_panel_button, adjust_panel_controller, adjust_panel_controller_when_set_ip, all_topology_status, arg, bring_back_footer, build_rclassmap, check_slection_data, currview, deferred, font_size, force, height, hide_and_inhibit_topology, hide_backto_setip_btn, hide_details, hide_footer, hide_iplslink, hide_link, hide_node, hide_zoom, inhibit_panel, init_panel, iplslink, k, lidx, link, links, lkdata, ls_line_height, lslink, lsnode, lsnode_padding_left, lsnode_padding_top, lsnoder, lsnodestokewidth, lsslct, lstext, mode, monitor_apply_ip_button, monitor_backward_to_selection, monitor_cancel_apply_ip_button, monitor_select_btn_group, move_panel, node, node_selecter, nodes, nodetext, panel, panel_ori_size, panel_resized, panelposleft, panelpostop, panelsvg, promise, raw, recovery, remove_apply_ip_button, remove_cancel_apply_ip_button, remove_panel_controller, remove_select_btn_group, remove_set_ip_button, resize_panel, ringid_class_idx, set_button_status, set_ip, show_details, show_iplslink, start, starting_point, svg, svg_pos_left, svg_pos_top, switch_between_mac_and_ip, tooltip, transition_speed, v, width, zoom, _i, _len, _ref, _ref1;
        arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        raw = arg[0];
        mode = arg[1];
        starting_point = arg[2];
        currview = arg[3];
        d3.select('#panel').style('opacity', 0);
        d3.select('#panelsvg').remove();
        d3.select('#panelselectionwrap').remove();
        d3.select('#panel').append('div').attr('id', 'panelselectionwrap');
        d3.select('#panelselectionwrap').append('svg').attr('id', 'panelsvg');
        d3.selectAll('.lsslct').remove();
        d3.selectAll('.lslink').remove();
        d3.selectAll('.ip_list').remove();
        d3.selectAll('.iplslink').remove();
        d3.select('#ip_panel').remove();
        d3.selectAll('.link').remove();
        d3.selectAll('.node').remove();
        d3.selectAll(".nodetext").remove();
        d3.select('.inhibit').remove();
        tooltip = CustomTooltip("details_tooltip", 400);
        tooltip.hideTooltip();
        show_details = function(dh) {
          var content, title, value;
          content = '';
          for (title in dh) {
            value = dh[title];
            content += "<span class=\"name\">" + title + ":</span><span class=\"value\"> " + value + "</span><br/>";
          }
          return tooltip.showTooltip(content, d3.event);
        };
        hide_details = function() {
          return tooltip.hideTooltip();
        };
        width = 1900;
        height = 1200;
        panelpostop = parseFloat($('#panel').css('top'));
        panelposleft = parseFloat($('#panel').css('left'));
        svg_pos_top = parseFloat($('#graph').css('top'));
        svg_pos_left = parseFloat($('#graph').css('left'));
        ls_line_height = 20;
        lsnoder = ls_line_height / 5;
        lsnode_padding_top = ls_line_height / 2 + lsnoder;
        lsnode_padding_left = ls_line_height / 2 - lsnoder - 1;
        lsnodestokewidth = 1;
        nodes = [];
        links = [];
        svg = d3.select('#toposvg').attr("width", width).attr("height", height);
        node = svg.selectAll(".node");
        nodetext = svg.selectAll(".nodetext");
        link = svg.selectAll(".link");
        lslink = svg.selectAll(".lslink");
        iplslink = svg.selectAll(".iplslink");
        panel = d3.select("#panel");
        panelsvg = d3.select('#panelsvg');
        lsnode = panelsvg.selectAll(".lsnode");
        lstext = d3.select("#panelselectionwrap").selectAll(".lstext");
        lsslct = d3.select("#panel").selectAll(".lsslct");
        font_size = 10;
        _ref = raw.nodes;
        for (k in _ref) {
          v = _ref[k];
          nodes.push(v);
        }
        /*
        for i in nodes
          i.x = 0
          i.y = 50000
        */

        if (raw.links != null) {
          _ref1 = raw.links;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            lkdata = _ref1[_i];
            lidx = lkdata.nodepair;
            links.push({
              source: nodes[lkdata.nodepair[0]],
              target: nodes[lkdata.nodepair[1]],
              ports: lkdata.portpair,
              blocked: lkdata.blocked,
              rings: lkdata.rings
            });
          }
        }
        ringid_class_idx = {};
        build_rclassmap = function(rings) {
          var i, id, ring, _results;
          i = 1;
          _results = [];
          for (id in rings) {
            ring = rings[id];
            ringid_class_idx[id] = i;
            _results.push(i += 1);
          }
          return _results;
        };
        build_rclassmap(raw.rings);
        force = d3.layout.force().nodes(nodes).links(links).charge(-1800).linkDistance(80).size([width, height]).gravity(0.1).on('tick', function() {
          node.attr({
            transform: function(d) {
              return "translate(" + d.x + "," + d.y + ")";
            }
          });
          nodetext.attr({
            transform: function(d) {
              return "translate(" + (d.x + -20) + "," + (d.y - 25) + ")";
            }
          });
          link.attr("d", function(d) {
            return "M" + d.source.x + "," + d.source.y + " " + "L" + d.target.x + "," + d.target.y;
          });
          lslink.attr({
            d: function(d, i) {
              return "M" + (panelposleft + lsnoder + lsnodestokewidth + lsnode_padding_left - svg_pos_left) + "," + (i * ls_line_height + panelpostop + lsnoder - lsnodestokewidth + lsnode_padding_top - svg_pos_top) + " " + "L" + d.x + "," + d.y;
            }
          });
          return iplslink.attr({
            d: function(d, i) {
              return "M" + (-298 + panelposleft + lsnoder + lsnodestokewidth + lsnode_padding_left - svg_pos_left) + "," + (i * ls_line_height + panelpostop + lsnoder - lsnodestokewidth + lsnode_padding_top - svg_pos_top) + " " + "L" + d.x + "," + d.y;
            }
          });
        });
        zoom = d3.select("#zoom").on("change", function() {
          var p;
          p = $("#zoom").val();
          d3.selectAll(".node").attr("r", p / 5 + 6).style({
            'stroke-width': p / 60 + 1
          });
          d3.selectAll('.nodetext').style("font-size", p / 10 + 3 + 'px');
          return force.linkDistance(p * 6 - 150).gravity(Math.abs(Math.log(p / 100) / 2)).start();
        });
        /*
        #force toggle
        force_toggle = d3.select("#f-toggle").on "change", () ->
          if(@.checked)
            force.start()
          else
            force.stop()
        #save pos of nodes
        snx = []
        sny = []
        save_pos = d3.select('#save').on "click", () ->
          snx.length = 0
          snx.length = 0
          for i, index in nodes
            snx.push(i.x)
            sny.push(i.y)
        #verify saved pos
        d3.select('#verify').on "click", () ->
          console.log nodes
          console.log links
        #restore pos of nodes
        restore_pos = d3.select('#restore').on "click", () ->
          for j, index in nodes
            j.x = snx[index]
            j.y = sny[index]
          start()
        #remove a link
        remove_link = d3.select('#remove-l').on "click", () ->
          links.pop()
          start()
        #remove a node
        remove_node = d3.select('#remove-n').on "click", () ->
          nodes.pop()
          start()
        #add a node
        add_node = d3.select('#add-n').on "click", () ->
          a =
            name: 'switch' + Math.ceil(Math.random()*(200-1)+1)
            location: 'fab' + Math.ceil(Math.random()*(10-1)+1)
            ip: '192.168.' + Math.ceil(Math.random()*(255-1)+1) + '.' + Math.ceil(Math.random()*(255-1)+1)
            mac: 'mac' + Math.ceil(Math.random()*(25555-1)+1)
          nodes.push a
          start()
        */

        start = function() {
          var adding_start, choose_ring, set_element_size, setpanel_size;
          choose_ring = function(rings) {
            var ring, thering, _j, _k, _l, _len1, _len2, _len3;
            for (_j = 0, _len1 = rings.length; _j < _len1; _j++) {
              ring = rings[_j];
              if (ring.role === 'owner') {
                return ring;
              }
            }
            for (_k = 0, _len2 = rings.length; _k < _len2; _k++) {
              ring = rings[_k];
              if (ring.type === 'major') {
                return ring;
              }
            }
            thering = rings[0];
            for (_l = 0, _len3 = rings.length; _l < _len3; _l++) {
              ring = rings[_l];
              if (thering.id > ring.id) {
                thering = ring;
              }
            }
            return thering;
          };
          adding_start = function() {
            var e, padding;
            lstext = lstext.data(force.nodes());
            lstext.exit().remove();
            padding = function() {
              if (nodes.length * ls_line_height > 350) {
                return lsnode_padding_top + lsnoder - lsnodestokewidth - font_size / 4;
              } else {
                return lsnode_padding_top + lsnoder - lsnodestokewidth - font_size / 2;
              }
            };
            lstext.enter().insert('span').attr({
              "class": function(d) {
                var a, clses, dmac, mac;
                clses = ['lstext'];
                dmac = 'MAC' + d.mac;
                mac = dmac.replace(/:/g, '');
                clses.push(mac);
                return a = clses.join(' ');
              }
            }).text(function(d) {
              return d.mac.toUpperCase();
            }).style({
              'height': ls_line_height + 'px',
              'font-size': font_size + 'px',
              'line-height': font_size + 'px',
              'padding-top': padding() + 'px'
            });
            lsnode = lsnode.data(force.nodes());
            lsnode.enter().append('circle').attr({
              transform: function(d, i) {
                return "translate(" + (lsnoder + lsnodestokewidth + lsnode_padding_left) + "," + (-2 + i * ls_line_height + lsnoder + lsnodestokewidth + lsnode_padding_top) + ")";
              },
              "class": function(d) {
                var b, clses, clsidx, dmac, mac, ring;
                clses = ['lsnode'];
                dmac = 'MAC' + d.mac;
                mac = dmac.replace(/:/g, '');
                clses.push(mac);
                if (currview === 'ring' && (d.rings != null) && d.rings.length > 0) {
                  ring = choose_ring(d.rings);
                  clsidx = ringid_class_idx[ring.id];
                  clses.push('ring_color' + clsidx);
                  if (ring.role === 'neighbour') {
                    clses.push('lsdashed');
                  }
                  if (ring.role === 'owner') {
                    clses.push('ring_owner_color' + clsidx);
                  }
                }
                if (currview === 'phy') {
                  clses.push('phymode');
                }
                if (d.rings == null) {
                  clses.push('othernode');
                }
                return b = clses.join(' ');
              },
              r: lsnoder
            }).style('stroke-width', lsnodestokewidth);
            lsnode.exit().remove();
            lsslct = lsslct.data(force.nodes());
            lsslct.enter().append('input').property('checked', false).attr({
              type: "checkbox",
              "class": function(d) {
                var a, clses, dmac, mac;
                clses = ['lsslct'];
                dmac = 'MAC' + d.mac;
                mac = dmac.replace(/:/g, '');
                clses.push(mac);
                return a = clses.join(' ');
              }
            });
            lsslct.exit().remove();
            lslink = lslink.data(force.nodes());
            lslink.enter().insert("path").attr({
              "class": function(d) {
                var a, clses, dmac, mac;
                clses = ['lslink'];
                dmac = 'MAC' + d.mac;
                mac = dmac.replace(/:/g, '');
                clses.push(mac);
                return a = clses.join(' ');
              }
            });
            lslink.exit().remove();
            iplslink = iplslink.data(force.nodes());
            iplslink.enter().insert("path").attr({
              "class": function(d) {
                var a, clses, dmac, mac;
                clses = ['iplslink'];
                dmac = 'MAC' + d.mac;
                mac = dmac.replace(/:/g, '');
                clses.push(mac);
                return a = clses.join(' ');
              }
            });
            iplslink.exit().remove();
            link = link.data(force.links());
            link.enter().insert("path").attr({
              "class": function(d) {
                var a, clses, clsidx, ring;
                clses = ['link'];
                if (currview === 'ring' && (d.rings != null) && d.rings.length > 0) {
                  ring = choose_ring(d.rings);
                  clsidx = ringid_class_idx[ring.id];
                  clses.push('ring_color' + clsidx);
                }
                if (currview === 'phy') {
                  clses.push('phymode');
                }
                if (d.blocked) {
                  clses.push('dashed');
                }
                if (d.source != null) {
                  clses.push(d.source.location.slice(3));
                }
                return a = clses.join(' ');
              }
            });
            link.on({
              mouseover: function(d, i) {
                d3.select(d3.event.target).classed('ln-hover', true);
                return show_details({
                  From: "" + d.source.mac + " -- Port " + d.ports[0],
                  To: "" + d.target.mac + " -- Port " + d.ports[1]
                });
              },
              mouseout: function(d, i) {
                d3.select(d3.event.target).classed('ln-hover', false);
                return hide_details(d, i, this);
              }
            });
            link.exit().remove();
            node = node.data(force.nodes());
            node.enter().append('circle').on({
              mouseover: function(d, i) {
                var ring, sd, _j, _len1, _ref2;
                d3.select(d3.event.target).classed('nd-hover', true);
                sd = {
                  Name: d.name,
                  Location: d.location + ("(" + i + ")"),
                  MAC: d.mac,
                  IP: d.ip
                };
                if ((d.rings != null) && d.rings.length > 0) {
                  if (d.rings.length > 1) {
                    _ref2 = d.rings;
                    for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
                      ring = _ref2[i];
                      sd["Ring" + i] = "as " + ring.role + " of " + ring.type + " Ring " + ring.id;
                    }
                  } else {
                    ring = d.rings[0];
                    sd["Ring"] = "as " + ring.role + " of " + ring.type + " Ring " + ring.id;
                  }
                }
                return show_details(sd);
              },
              mouseout: function(d, i) {
                d3.select(d3.event.target).classed('nd-hover', false);
                return hide_details(d, i, this);
              },
              mouseup: function(d, i) {
                return node_selecter(d, i, transition_speed, true, 'single_mode');
              }
            }).attr({
              "class": function(d) {
                var a, clses, clsidx, dmac, mac, ring;
                clses = ['node'];
                dmac = 'MAC' + d.mac;
                mac = dmac.replace(/:/g, '');
                clses.push(mac);
                if (currview === 'ring' && (d.rings != null) && d.rings.length > 0) {
                  ring = choose_ring(d.rings);
                  clsidx = ringid_class_idx[ring.id];
                  clses.push('ring_color' + clsidx);
                  if (ring.role === 'neighbour') {
                    clses.push('dashed');
                  }
                  if (ring.role === 'owner') {
                    clses.push('ring_owner_color' + clsidx);
                  }
                }
                if (currview === 'phy') {
                  clses.push('phymode');
                }
                if (d.rings == null) {
                  clses.push('othernode');
                }
                return a = clses.join(' ');
              },
              r: '15'
            }).call(force.drag);
            node.exit().remove();
            nodetext = nodetext.data(force.nodes());
            nodetext.enter().append('text').on({
              mouseover: function(d, i) {
                return d3.select(d3.event.target).classed('nodetext-hover', true);
              },
              mouseout: function(d) {
                return d3.select(d3.event.target).classed('nodetext-hover', false);
              }
            }).text(function(d) {
              return d.name;
            }).attr('text-anchor', 'middle').attr({
              "class": function(d) {
                var a, clses, dmac, mac;
                clses = ['nodetext'];
                dmac = 'MAC' + d.mac;
                mac = dmac.replace(/:/g, '');
                clses.push(mac);
                return a = clses.join(' ');
              }
            }).call(force.drag);
            nodetext.exit().remove();
            try {
              return force.start();
            } catch (_error) {
              e = _error;
              return console.log(e);
            }
          };
          set_element_size = function() {
            ls_line_height = Math.min((1 / Math.log(nodes.length)) * 80, 40);
            lsnoder = ls_line_height / 5;
            lsnode_padding_top = ls_line_height / 2 - lsnoder;
            lsnode_padding_left = ls_line_height / 2 - lsnoder - 1;
            font_size = Math.min(Math.max(ls_line_height / 2.428, 10), 13);
            return setpanel_size();
          };
          setpanel_size = function() {
            if (nodes.length * ls_line_height > 350) {
              panel.transition().style({
                opacity: 1,
                height: '350px'
              }).duration(20);
              lsnoder = ls_line_height / 5;
              panelsvg.transition().attr("width", ls_line_height / 5 * 4).attr('height', nodes.length * ls_line_height).duration(100);
              d3.select("#panelselectionwrap").style({
                'overflow-y': 'scroll'
              });
            } else {
              panel.transition().style({
                opacity: 1,
                height: (nodes.length * ls_line_height) + 'px'
              }).duration(20);
              panelsvg.transition().attr("width", ls_line_height / 5 * 4).attr('height', nodes.length * ls_line_height).duration(100);
            }
            return adding_start();
          };
          return set_element_size();
        };
        start();
        transition_speed = 30;
        all_topology_status = function(toggle) {
          d3.selectAll('.node').classed('node_active', toggle);
          d3.selectAll('.lsnode').classed('lsnode_active', toggle);
          if (nodes.length * ls_line_height < 350) {
            d3.selectAll('.lslink').classed('lslink_active', toggle);
          }
          d3.selectAll('.lstext').classed('lstext_active', toggle);
          return d3.selectAll('.lsslct').property('checked', toggle);
        };
        set_button_status = function(toggle) {
          if (toggle === false) {
            $('#set').css('background-color', 'rgba(41,95,176,0.2)');
          }
          if (toggle === true) {
            return $('#set').css('background-color', 'rgba(41,95,176,0.7)');
          }
        };
        check_slection_data = function() {
          if (window.targetip.length === 0) {
            return set_button_status(false);
          } else {
            return set_button_status(true);
          }
        };
        node_selecter = function(d, i, transition_speed, change_lsslct_status, select_all) {
          var dmac, element, mac, search, single_topology_status, target_status, _j, _len1;
          switch (select_all) {
            case true:
              for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
                i = nodes[_j];
                window.targetip.push(i.ip);
              }
              if (nodes.length * ls_line_height < 350) {
                d3.selectAll('.lslink').transition().style('stroke-dashoffset', 0).duration(transition_speed * 60);
              }
              all_topology_status(true);
              check_slection_data();
              return console.log(window.targetip);
            case false:
              window.targetip = [];
              if (nodes.length * ls_line_height < 350) {
                d3.selectAll('.lslink').transition().style('stroke-dashoffset', 30000).duration(transition_speed * 8);
              }
              all_topology_status(false);
              check_slection_data();
              return console.log(window.targetip);
            case 'single_mode':
              dmac = 'MAC' + d.mac;
              mac = dmac.replace(/:/g, '');
              element = d.ip;
              target_status = d3.select('.lsslct' + '.' + mac).property('checked');
              single_topology_status = function(toggle) {
                d3.select('.node' + '.' + mac).classed('node_active', toggle);
                if (nodes.length * ls_line_height < 350) {
                  d3.select('.lslink' + '.' + mac).classed('lslink_active', toggle);
                }
                d3.select('.lsnode' + '.' + mac).classed('lsnode_active', toggle);
                return d3.select('.lstext' + '.' + mac).classed('lstext_active', toggle);
              };
              if (target_status === true) {
                if (change_lsslct_status === true) {
                  d3.select('.lsslct' + '.' + mac).property('checked', false);
                }
                single_topology_status(false);
                if (nodes.length * ls_line_height < 350) {
                  d3.select('.lslink' + '.' + mac).transition().style('stroke-dashoffset', 30000).duration(transition_speed * 8);
                }
                search = window.targetip.indexOf(element);
                window.targetip.splice(search, 1);
                check_slection_data();
                return console.log(window.targetip);
              } else {
                if (change_lsslct_status === true) {
                  d3.select('.lsslct' + '.' + mac).property('checked', true);
                }
                single_topology_status(true);
                if (nodes.length * ls_line_height < 350) {
                  d3.select('.lslink' + '.' + mac).transition().style('stroke-dashoffset', 0).duration(transition_speed * 60);
                }
                window.targetip.push(element);
                check_slection_data();
                return console.log(window.targetip);
              }
          }
        };
        panel_ori_size = 210;
        panel_resized = parseFloat($('#noti').css('width'));
        init_panel = function() {
          d3.select('#paneltitle').style('width', panel_ori_size + 'px');
          d3.select('#panel').style('width', panel_ori_size + 'px');
          d3.select('#panel_bg').transition().style('opacity', 1).duration(800);
          return d3.select('#topocontroller').transition().style('opacity', 1).duration(1200);
        };
        resize_panel = function() {
          return d3.select('#panel').style('width', panel_resized + 'px');
        };
        inhibit_panel = function() {
          d3.select('#panel').append('div').attr('class', 'inhibit');
          return d3.select('#paneltitle').transition().style('opacity', 0).duration(100);
        };
        hide_node = function() {
          d3.selectAll('.node').transition().style('opacity', 0.6).duration(1000);
          return d3.selectAll('.nodetext').transition().style('opacity', 0.1).duration(1000);
        };
        hide_link = function() {
          d3.selectAll('.lslink').transition().style('opacity', 0).duration(300);
          return d3.selectAll('.link').transition().style('opacity', 0.6).duration(1000);
        };
        hide_and_inhibit_topology = function() {
          d3.select('#graph').append('div').attr('class', 'inhibit');
          return d3.select('#graph').transition().style('opacity', 0.8).duration(1000);
        };
        hide_zoom = function() {
          return d3.select('#topocontroller').transition().style('opacity', 0).duration(1000);
        };
        add_panel_controller = function() {
          return d3.select('#panel').append('div').attr('id', 'panel_controller').style('width', panel_ori_size + 'px');
        };
        remove_panel_controller = function() {
          return d3.select('#panel_controller').remove();
        };
        adjust_panel_controller_when_set_ip = function() {
          return d3.select('#panel_controller').transition().style({
            width: panel_resized + 100 + 'px',
            bottom: -130 + 'px',
            left: -300 + 'px'
          }).duration(0);
        };
        adjust_panel_controller = function(botoom) {
          d3.select('#panel_controller').transition().style({
            width: panel_resized + 'px',
            bottom: botoom + 'px'
          }).duration(200);
          return d3.select('#paneltitle').transition().style('width', panel_resized + 'px').duration(1000);
        };
        add_select_btn_group = function() {
          d3.select('#panel_controller').append('a').attr({
            id: 'set',
            "class": 'btn btn-primary'
          }).text("Config Mode ").append('i').attr('class', 'fa fa-cog');
          d3.select('#addall').style('display', 'inline-block');
          d3.select('#rmall').style('display', 'none');
          d3.select('#mac_mode').style('display', 'inline-block');
          d3.select('#ip_mode').style('display', 'none');
          return d3.select('#name_mode').style('display', 'none');
        };
        remove_select_btn_group = function() {
          d3.select('#rmall').style('display', 'none');
          d3.select('#addall').style('display', 'none');
          d3.select('#mac_mode').style('display', 'none');
          d3.select('#ip_mode').style('display', 'none');
          d3.select('#name_mode').style('display', 'none');
          return d3.select('#set').remove();
        };
        add_backward_to_selection = function() {
          return d3.select('#panel_controller').append('a').attr('id', 'back').attr('class', 'btn btn-danger').text("Device Browsing ").append('i').attr('class', 'fa fa-code-fork');
        };
        move_panel = function() {
          d3.select('#paneltitle').transition().style({
            opacity: 0
          }).duration(800);
          d3.select('#panel').transition().style({
            width: panel_resized + 'px',
            top: 187 + 'px',
            left: 15 + 'px'
          }).duration(1000);
          return d3.select('#panel_controller').transition().style({
            bottom: -82 + 'px',
            width: panel_resized + 'px'
          }).duration(1500);
        };
        adjust_panel_button = function() {};
        recovery = function() {
          d3.select('#panel').classed('panel_ready', false);
          d3.selectAll('.inhibit').remove();
          d3.select('#panel_controller').remove();
          d3.select('#ip_panel').remove();
          d3.select('#panel').transition().style({
            width: panel_ori_size + 'px',
            top: 68 + 'px',
            left: 972 + 'px',
            opacity: 1
          }).duration(500);
          if (nodes.length * ls_line_height < 350) {
            d3.selectAll('.lslink').transition().style('opacity', 1).duration(300);
          }
          d3.select('#graph').transition().style('opacity', 1).duration(1000);
          d3.selectAll('.node').transition().style('opacity', 1).duration(1000);
          d3.selectAll('.link').transition().style('opacity', 1).duration(1000);
          d3.selectAll('.nodetext').transition().style('opacity', 0.35).duration(1000);
          d3.select('#topocontroller').transition().style('opacity', 1).duration(1000);
          d3.select('#panel_controller').transition().style({
            opacity: 1,
            bottom: -124 + 'px'
          }).duration(1500);
          d3.select('#paneltitle').transition().style({
            opacity: 1,
            width: panel_ori_size + 'px'
          }).duration(500);
          d3.selectAll('.lstext').classed('apply_fail', false);
          d3.selectAll('.lstext').classed('same', false);
          d3.selectAll('.lstext').classed('host', false);
          d3.selectAll('.lstext').classed('diff', false);
          d3.selectAll('.lstext').classed('lstext_active', false);
          d3.selectAll('.lsnode').classed('lsnode_active', false);
          if (nodes.length * ls_line_height < 350) {
            d3.selectAll('.lslink').classed('lslink_active', false);
          }
          d3.selectAll('.node').classed('node_active', false);
          return d3.selectAll('.lsslct').property('checked', false);
        };
        add_set_ip_button = function() {
          return d3.select('#panel_controller').append('a').attr({
            id: 'setip',
            "class": 'btn btn-primary'
          }).text("Set IP ").append('i').attr('class', 'fa fa-arrow-circle-right');
        };
        remove_set_ip_button = function() {
          return d3.select('#setip').remove();
        };
        add_ip_panel = function() {
          var ip_panelheight;
          ip_panelheight = _.size(force.nodes()) * ls_line_height;
          if (ip_panelheight > 350) {
            d3.select('#panel').append('div').attr('id', 'ip_panel').style({
              height: '350px',
              opacity: 1,
              overflow: 'hidden',
              'overflow-y': 'visible'
            });
            $('#ip_panel').on("scroll", function() {
              return $('#panelselectionwrap').scrollTop($(this).scrollTop());
            });
          } else {
            d3.select('#panel').append('div').attr('id', 'ip_panel').style({
              height: ip_panelheight + 'px',
              opacity: 1
            });
          }
          return d3.select('#ip_panel').append('form').attr('id', 'ip_form');
        };
        add_apply_ip_button = function() {
          return d3.select('#panel_controller').append('a').attr('id', 'applyip').attr('class', 'btn btn-primary').text("Apply ").append('i').attr('class', 'fa fa-cloud-upload');
        };
        add_cancel_apply_ip_button = function() {
          return d3.select('#panel_controller').append('a').attr('id', 'cancel_applyip').attr('class', 'btn btn-danger').text("Skip ").append('i').attr('class', 'fa fa-forward');
        };
        remove_apply_ip_button = function() {
          return d3.select('#applyip').remove();
        };
        remove_cancel_apply_ip_button = function() {
          return d3.select('#cancel_applyip').remove();
        };
        add_ip_panel_items = function() {
          var ip_list, text_padding, text_size;
          ip_list = d3.select('#ip_form').selectAll('.ip_list');
          ip_list = ip_list.data(force.nodes());
          text_padding = lsnode_padding_top + lsnoder - lsnodestokewidth - font_size / 2 - 0.5;
          text_size = font_size;
          ip_list.enter().append('div').style({
            'height': ls_line_height + 'px'
          }).attr({
            "class": 'ip_list'
          });
          ip_list.append('span').style({
            'font-size': text_size + 'px',
            'padding-top': text_padding + 'px',
            'float': 'left'
          }).text(function(d) {
            return d.name;
          });
          ip_list.insert('i', 'span').attr('class', 'fa fa-dot-circle-o').style({
            'font-size': text_size + 'px',
            'padding-top': text_padding + 'px',
            'float': 'left'
          });
          ip_list.append('i').attr('class', 'fa fa-chevron-right').style({
            'font-size': text_size + 'px',
            'padding-top': text_padding + 'px'
          });
          ip_list.insert('input', 'i.fa.fa-chevron-right').attr({
            "class": 'ip_input ipv4 required',
            type: 'text',
            value: function(d) {
              if (d.ip != null) {
                return d.ip;
              } else {
                return null;
              }
            }
          }).style({
            'height': ls_line_height * 0.8 + 'px',
            'font-size': text_size * 0.75 + 'px',
            'padding-top': text_size * 0.25 + 'px',
            'padding-left': text_size * 0.5 + 'px',
            'margin-top': ls_line_height * 0.1 + 'px'
          }).on({
            mouseenter: function(d, i) {
              var mac, t;
              mac = 'MAC' + d.mac;
              t = mac.replace(/:/g, '');
              d3.select('.node' + '.' + t).classed('node_active_blue', true);
              if (nodes.length * ls_line_height < 350) {
                d3.select('.iplslink' + '.' + t).classed('iplslink_active_blue', true);
              }
              d3.select('.lstext' + '.' + t).classed('lstext_active', true);
              return d3.select('.nodetext' + '.' + t).classed('nodetext-hover', true);
            },
            mouseout: function(d, i) {
              var mac, t;
              mac = 'MAC' + d.mac;
              t = mac.replace(/:/g, '');
              d3.select('.node' + '.' + t).classed('node_active_blue', false);
              if (nodes.length * ls_line_height < 350) {
                d3.select('.iplslink' + '.' + t).classed('iplslink_active_blue', false);
              }
              d3.select('.lstext' + '.' + t).classed('lstext_active', false);
              return d3.select('.nodetext' + '.' + t).classed('nodetext-hover', false);
            }
          });
          return ip_list.exit().remove();
        };
        hide_iplslink = function() {
          if (nodes.length * ls_line_height < 350) {
            return d3.selectAll('.iplslink').style('opacity', 0);
          }
        };
        show_iplslink = function() {
          if (nodes.length * ls_line_height < 350) {
            return d3.selectAll('.iplslink').style('opacity', 1);
          }
        };
        add_validate = function() {
          return $("#ip_form").validate({
            errorElement: 'img'
          });
        };
        add_show_detail_panel = function() {
          var ip_list, ip_panelheight, text_padding, text_size;
          ip_panelheight = _.size(force.nodes()) * ls_line_height;
          d3.select('#panel').append('div').attr('id', 'show_detail_panel').transition().style({
            height: ip_panelheight + 'px',
            opacity: 0.9
          }).duration(700);
          d3.select('#show_detail_panel').append('form').attr('id', 'ip_show');
          ip_list = d3.select('#ip_show').selectAll('.ip_list');
          ip_list = ip_list.data(force.nodes());
          text_padding = lsnode_padding_top + lsnoder - lsnodestokewidth - font_size / 2 - 0.5;
          text_size = font_size;
          ip_list.enter().append('div').style({
            'height': ls_line_height + 'px'
          }).attr({
            "class": 'ip_list'
          });
          ip_list.append('span').style({
            'font-size': text_size + 'px',
            'padding-top': text_padding + 'px',
            color: 'rgba(0,0,0,0.1)'
          }).text(function(d) {
            return d.name;
          });
          ip_list.insert('i', 'span').attr('class', 'fa fa-dot-circle-o').style({
            'font-size': text_size + 'px',
            'padding-top': text_padding + 'px',
            opacity: 0
          });
          ip_list.append('i').attr('class', 'fa fa-chevron-right').style({
            'font-size': text_size + 'px',
            'padding-top': text_padding + 'px'
          });
          ip_list.insert('span', 'i.fa.fa-chevron-right').attr('class', 'ip_input').text(function(d) {
            return d.mac;
          }).style({
            'font-size': text_size + 'px',
            color: 'rgba(0,0,0,0.3)',
            'padding-top': text_size + 'px',
            'padding-left': text_size * 0.5 + 'px',
            'margin-top': text_padding * 0.5 + 'px'
          });
          return ip_list.exit().remove();
        };
        switch_between_mac_and_ip = function(option) {
          if (option === 'mac') {
            lstext = d3.select("#panelselectionwrap").selectAll(".lstext");
            lstext = lstext.data(force.nodes());
            lstext.enter();
            lstext.text(function(d) {
              return d.mac.toUpperCase();
            });
            d3.select('#backto_setip_btn').style('display', 'none');
          }
          if (option === 'ip') {
            lstext = d3.select("#panelselectionwrap").selectAll(".lstext");
            lstext = lstext.data(force.nodes());
            lstext.enter();
            lstext.text(function(d) {
              return d.ip;
            });
            d3.select('#backto_setip_btn').style('display', 'block');
          }
          if (option === 'name') {
            lstext = d3.select("#panelselectionwrap").selectAll(".lstext");
            lstext = lstext.data(force.nodes());
            lstext.enter();
            lstext.text(function(d) {
              return d.name;
            });
            return d3.select('#backto_setip_btn').style('display', 'none');
          }
        };
        add_backto_setip_btn = function() {
          d3.select('#backto_setip_btn').style('display', 'block');
          return d3.select('#backto_setip_btn').on('click', function() {
            set_ip();
            d3.select('#backto_setip_btn').style('display', 'none');
            d3.selectAll('.node').classed('node_active', false);
            d3.selectAll('.lsnode').classed('lsnode_active', false);
            if (nodes.length * ls_line_height < 350) {
              d3.selectAll('.lslink').classed('lslink_active', false);
            }
            d3.selectAll('.lstext').classed('lstext_active', false);
            d3.selectAll('.lsslct').property('checked', false);
            return window.targetip = [];
          });
        };
        hide_backto_setip_btn = function() {
          return d3.select('#backto_setip_btn').style('display', 'none');
        };
        hide_footer = function() {
          return d3.select('#menubar').transition().style({
            top: 700 + 'px',
            opacity: 0
          }).duration(2000);
        };
        bring_back_footer = function() {
          return d3.select('#menubar').transition().style({
            top: 565 + 'px',
            opacity: 1
          }).duration(300);
        };
        monitor_select_btn_group = function() {
          d3.select('#set').on('click', function() {
            var ck, deferred, promise, retry;
            if (window.targetip.length === 0) {
              effect.animated("#set", "shake");
              effect.animated(".lstext", "flash");
              msgbox.msgbar_show('please select a device to config', 'error');
              return $rootScope.$apply();
            } else {
              window.agent_start();
              window.smith_reconnect = true;
              effect.show_spinner('Applying');
              deferred = new $q.defer();
              promise = deferred.promise;
              promise = promise.then(resize_panel).then(inhibit_panel).then(hide_link).then(hide_node).then(hide_and_inhibit_topology).then(hide_zoom).then(remove_select_btn_group).then(adjust_panel_controller(-89)).then(add_backward_to_selection).then(monitor_backward_to_selection).then(hide_footer).then(hide_backto_setip_btn);
              deferred.resolve();
              retry = 0;
              ck = function() {
                retry = retry + 1;
                if (window.agent.length === window.targetip.length || retry > 8) {
                  console.log(window.agent);
                  console.log(window.targetip);
                  effect.hide_spinner();
                  clearInterval(window.check_agent);
                  msgbox.msgbar_show('please select desire configuration to set device', 'instruction');
                  deferred = new $q.defer();
                  promise = deferred.promise;
                  promise = promise.then(move_panel).then(adjust_panel_button);
                  deferred.resolve();
                  $rootScope.showconfigs = true;
                  return $rootScope.$apply();
                } else {
                  return msgbox.msgbar_show('Connecting to selected devices. Please wait...', 'info');
                }
              };
              return window.check_agent = setInterval(ck, 2000);
            }
          });
          d3.select('#addall').on('click', function() {
            node_selecter(null, null, transition_speed, null, true);
            d3.select('#addall').style('display', 'none');
            return d3.select('#rmall').style('display', 'inline-block');
          });
          d3.select('#rmall').on('click', function() {
            node_selecter(null, null, transition_speed, false, false);
            d3.select('#addall').style('display', 'inline-block');
            return d3.select('#rmall').style('display', 'none');
          });
          d3.select('#mac_mode').on('click', function() {
            d3.select('#mac_mode').style('display', 'none');
            d3.select('#ip_mode').style('display', 'inline-block');
            d3.select('#name_mode').style('display', 'none');
            return switch_between_mac_and_ip('mac');
          });
          d3.select('#ip_mode').on('click', function() {
            d3.select('#ip_mode').style('display', 'none');
            d3.select('#name_mode').style('display', 'inline-block');
            d3.select('#mac_mode').style('display', 'none');
            return switch_between_mac_and_ip('ip');
          });
          return d3.select('#name_mode').on('click', function() {
            d3.select('#name_mode').style('display', 'none');
            d3.select('#ip_mode').style('display', 'none');
            d3.select('#mac_mode').style('display', 'inline-block');
            return switch_between_mac_and_ip('name');
          });
        };
        monitor_backward_to_selection = function() {
          return d3.select('#back').on('click', function() {
            var agent, deferred, promise, _j, _len1, _ref2;
            deferred = new $q.defer();
            promise = deferred.promise;
            promise = promise.then(recovery).then(add_panel_controller).then(add_select_btn_group).then(monitor_select_btn_group).then(bring_back_footer).then(add_backto_setip_btn);
            deferred.resolve();
            msgbox.msgbar_show('please select desire devices to config', 'instruction');
            $rootScope.showconfigs = false;
            $rootScope.$apply();
            _ref2 = window.agent;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              agent = _ref2[_j];
              agent.disconnect('by manaul');
            }
            window.smith_reconnect = false;
            window.targetip = [];
            window.config_data = {};
            return clearInterval(window.check_agent);
          });
        };
        monitor_apply_ip_button = function() {
          return d3.select('#applyip').on('click', function() {
            var build_messages_array, deferred, desire_ip, i, original, promise, send, _j, _len1, _ref2;
            if ($(".ip_input:blank").length === 0) {
              if (d3.select('.ip_input.error').empty()) {
                desire_ip = [];
                $('.ip_input').each(function() {
                  return desire_ip.push($(this).val());
                });
                clearInterval(window.regular_rechecking);
                window.targetmac = [];
                _ref2 = force.nodes();
                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                  i = _ref2[_j];
                  if (i.mac != null) {
                    window.targetmac.push(i.mac);
                  }
                }
                console.log(window.targetmac);
                window.desire_ip = desire_ip;
                build_messages_array = function() {
                  var buildmessage, ips, key, macs, _k, _len2, _results;
                  ips = window.desire_ip;
                  macs = window.targetmac;
                  window.messages = [];
                  buildmessage = function(mac, ip) {
                    var gateway, head, message, tail;
                    head = ip.slice(0, ip.lastIndexOf("."));
                    tail = '.254';
                    gateway = head.concat(tail);
                    message = {
                      key: 'intrising',
                      type: 'api',
                      mac: mac,
                      api: {
                        name: 'system::set_net_cfg',
                        args: {
                          ipaddr: ip,
                          gatewayip: gateway
                        }
                      }
                    };
                    return message;
                  };
                  _results = [];
                  for (key = _k = 0, _len2 = ips.length; _k < _len2; key = ++_k) {
                    i = ips[key];
                    _results.push(window.messages.push(buildmessage(macs[key], ips[key])));
                  }
                  return _results;
                };
                build_messages_array();
                send = function() {
                  var _k, _len2, _ref3, _results;
                  _ref3 = window.messages;
                  _results = [];
                  for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                    i = _ref3[_k];
                    _results.push(window.mr.mcastsend(i, window["interface"]));
                  }
                  return _results;
                };
                send();
                original = force.nodes();
                _.map(original, function(value, key) {
                  return value.ip = window.desire_ip[key];
                });
                msgbox.msgbar_show('Please wait. Intriconfig is applying IPs to devices...', 'info');
                effect.show_spinner('Applying');
                deferred = new $q.defer();
                promise = deferred.promise;
                promise = promise.then(hide_iplslink).then(remove_apply_ip_button).then(remove_cancel_apply_ip_button).then(recovery).then(inhibit_panel).then(hide_footer);
                deferred.resolve();
                return setTimeout((function() {
                  var padding;
                  effect.hide_spinner();
                  msgbox.msgbar_show('set IPs to devices', 'success');
                  deferred = new $q.defer();
                  promise = deferred.promise;
                  promise = promise.then(recovery).then(add_panel_controller).then(add_select_btn_group).then(monitor_select_btn_group).then(add_backto_setip_btn).then(bring_back_footer);
                  deferred.resolve();
                  d3.selectAll('.lstext').remove();
                  lstext = d3.select("#panelselectionwrap").selectAll(".lstext");
                  lstext = lstext.data(force.nodes());
                  padding = function() {
                    if (nodes.length * ls_line_height > 350) {
                      return lsnode_padding_top + lsnoder - lsnodestokewidth - font_size / 4;
                    } else {
                      return lsnode_padding_top + lsnoder - lsnodestokewidth - font_size / 2;
                    }
                  };
                  lstext.enter().insert('span').attr({
                    "class": function(d) {
                      var a, clses, dip, dmac, ip, mac;
                      clses = ['lstext'];
                      dmac = 'MAC' + d.mac;
                      mac = dmac.replace(/:/g, '');
                      dip = 'IP' + d.ip;
                      ip = dip.replace(/\./g, '');
                      clses.push(mac);
                      clses.push(ip);
                      return a = clses.join(' ');
                    }
                  }).text(function(d) {
                    return d.ip;
                  }).style({
                    'height': ls_line_height + 'px',
                    'font-size': font_size + 'px',
                    'line-height': font_size + 'px',
                    'padding-top': padding() + 'px'
                  });
                  lstext.on({
                    mousedown: function(d, i) {
                      return node_selecter(d, i, transition_speed, true, 'single_mode');
                    }
                  });
                  return window.targetip = [];
                }), 60000);
              } else {
                effect.animated("#applyip", "shake");
                return msgbox.msgbar_show('please input valid IP adress', 'error');
              }
            } else {
              effect.animated("#applyip", "shake");
              $(".ip_input:blank").addClass("error");
              return msgbox.msgbar_show('empty input', 'error');
            }
          });
        };
        monitor_cancel_apply_ip_button = function() {
          var trying;
          trying = 0;
          return d3.select('#cancel_applyip').on('click', function() {
            var deferred, desire_ip, padding, promise, uips;
            if ($(".ip_input:blank").length === 0 || trying !== 0) {
              if (d3.select('.ip_input.error').empty() || trying !== 0) {
                desire_ip = [];
                $('.ip_input').each(function() {
                  return desire_ip.push($(this).val());
                });
                uips = _.uniq(desire_ip);
                if (_.size(uips) === _.size(desire_ip) || trying !== 0) {
                  clearInterval(window.regular_rechecking);
                  deferred = new $q.defer();
                  promise = deferred.promise;
                  promise = promise.then(hide_iplslink).then(remove_apply_ip_button).then(remove_cancel_apply_ip_button).then(recovery).then(inhibit_panel).then(recovery).then(add_panel_controller).then(add_select_btn_group).then(monitor_select_btn_group).then(bring_back_footer).then(add_backto_setip_btn);
                  deferred.resolve();
                  setTimeout((function() {
                    return effect.animated(".lstext", "flash");
                  }), 2300);
                  d3.selectAll('.lstext').remove();
                  lstext = d3.select("#panelselectionwrap").selectAll(".lstext");
                  lstext = lstext.data(force.nodes());
                  padding = function() {
                    if (nodes.length * ls_line_height > 350) {
                      return lsnode_padding_top + lsnoder - lsnodestokewidth - font_size / 4;
                    } else {
                      return lsnode_padding_top + lsnoder - lsnodestokewidth - font_size / 2;
                    }
                  };
                  lstext.enter().insert('span').attr({
                    "class": function(d) {
                      var a, clses, dip, dmac, ip, mac;
                      clses = ['lstext'];
                      dmac = 'MAC' + d.mac;
                      mac = dmac.replace(/:/g, '');
                      dip = 'IP' + d.ip;
                      ip = dip.replace(/\./g, '');
                      clses.push(mac);
                      clses.push(ip);
                      return a = clses.join(' ');
                    }
                  }).text(function(d) {
                    return d.ip;
                  }).style({
                    'height': ls_line_height + 'px',
                    'font-size': font_size + 'px',
                    'line-height': font_size + 'px',
                    'padding-top': padding() + 'px'
                  });
                  lstext.on({
                    mousedown: function(d, i) {
                      return node_selecter(d, i, transition_speed, true, 'single_mode');
                    }
                  });
                  return window.targetip = [];
                } else {
                  effect.animated("#cancel_applyip", "shake");
                  msgbox.msgbar_show('some of the devices have duplicate ip addresses, you need to set unique ip for each of them in order to configure other settings', 'error');
                  setTimeout((function() {
                    return effect.animated("#applyip", "flash");
                  }), 2500);
                  $rootScope.$apply();
                  return trying = 1;
                }
              } else {
                effect.animated("#cancel_applyip", "shake");
                msgbox.msgbar_show('some of the devices do not have valid ip address, you need to set valid ip for them in order to configure other settings', 'error');
                $rootScope.$apply();
                setTimeout((function() {
                  return effect.animated("#applyip", "flash");
                }), 2500);
                return trying = 1;
              }
            } else {
              effect.animated("#cancel_applyip", "shake");
              msgbox.msgbar_show('some of the devices do not have ip address, you need to set ip for them in order to configure other settings', 'error');
              $rootScope.$apply();
              setTimeout((function() {
                return effect.animated("#applyip", "flash");
              }), 2500);
              return trying = 1;
            }
          });
        };
        set_ip = function() {
          var deferred, promise;
          deferred = new $q.defer();
          promise = deferred.promise;
          promise = promise.then(init_panel).then(remove_panel_controller).then(add_panel_controller).then(add_apply_ip_button).then(add_cancel_apply_ip_button).then(resize_panel).then(adjust_panel_controller_when_set_ip).then(inhibit_panel).then(hide_and_inhibit_topology).then(add_ip_panel).then(add_ip_panel_items).then(show_iplslink).then(add_validate).then(monitor_apply_ip_button).then(monitor_cancel_apply_ip_button).then(inhibit_panel).then(bring_back_footer);
          msgbox.msgbar_show('please set ip first in order to configure devices', 'info');
          return deferred.resolve();
        };
        if (mode === 'demo') {
          d3.selectAll('.lslink').style('display', 'none');
          d3.select('#panel').style('display', 'none');
          d3.select('#topocontroller').style({
            top: 210 + 'px',
            left: 982 + 'px',
            opacity: 1
          });
          d3.select('#panel_bg').transition().style({
            opacity: 1,
            left: 980 + 'px'
          }).duration(800);
          msgbox.msgbar_show('demo mode', 'info');
        }
        if (mode === 'scan') {
          if (starting_point === 'set_config') {
            deferred = new $q.defer();
            promise = deferred.promise;
            promise = promise.then(init_panel).then(remove_panel_controller).then(add_panel_controller).then(add_select_btn_group).then(monitor_select_btn_group);
            deferred.resolve();
          }
          if (starting_point === 'set_ip') {
            return set_ip();
          }
        }
      }
    };
  });

  ngapp.service('data', function($rootScope, smith, $q) {
    return {
      processer: function(devs) {
        var add_to_linkset, blkports, d, enhanced_equlink, equlink, find_dup_n, find_linkidx, find_node_idx, glinks, gnodes, grings, l, link, linkidx, mring, n0, n1, node, omit_dup, p, r, rid, ring, rlinkidx, rnode, upports, _fn, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        grings = {};
        gnodes = [];
        glinks = [];
        find_node_idx = function(mac) {
          var i, node, _i, _len;
          for (i = _i = 0, _len = gnodes.length; _i < _len; i = ++_i) {
            node = gnodes[i];
            if (node.mac === mac) {
              return i;
            }
          }
          return -1;
        };
        add_to_linkset = function(linkset, link) {
          var duplinks, l;
          duplinks = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = linkset.length; _i < _len; _i++) {
              l = linkset[_i];
              if (enhanced_equlink(link, l)) {
                _results.push(l);
              }
            }
            return _results;
          })();
          if (duplinks.length === 0) {
            return linkset.push(link);
          }
        };
        n0 = -1;
        n1 = -1;
        omit_dup = function(linkset) {
          var j, _i, _len, _results;
          if ((linkset != null) && linkset !== []) {
            _results = [];
            for (_i = 0, _len = linkset.length; _i < _len; _i++) {
              j = linkset[_i];
              _results.push((function(j) {
                var n;
                if ((j != null) && (j.nodepair != null) && j.blocked === false) {
                  if ((j.nodepair[0] === n0 && j.nodepair[1] === n1) || (j.nodepair[0] === n1 && j.nodepair[1] === n0) === true) {
                    n = linkset.indexOf(j);
                    linkset.splice(n, 1);
                    return console.log('duplicated data of link is deleted');
                  }
                }
              })(j));
            }
            return _results;
          }
        };
        find_dup_n = function(linkset) {
          var i, _i, _len, _results;
          if ((linkset != null) && linkset !== []) {
            _results = [];
            for (_i = 0, _len = linkset.length; _i < _len; _i++) {
              i = linkset[_i];
              _results.push((function(i) {
                if ((i != null) && (i.blocked != null) && i.blocked === true) {
                  n0 = i.nodepair[0];
                  n1 = i.nodepair[1];
                  return omit_dup(linkset);
                }
              })(i));
            }
            return _results;
          }
        };
        find_linkidx = function(mac, pno) {
          var i, l, nidx, _i, _len;
          nidx = find_node_idx(mac);
          for (i = _i = 0, _len = glinks.length; _i < _len; i = ++_i) {
            l = glinks[i];
            if ((nidx === l.nodepair[0] && pno === l.portpair[0]) || (nidx === l.nodepair[1] && pno === l.portpair[1])) {
              return i;
            }
          }
        };
        equlink = function(lka, lkb) {
          return (lka.nodepair[0] === lkb.nodepair[0] && lka.nodepair[1] === lkb.nodepair[1]) || (lka.nodepair[0] === lkb.nodepair[1] && lka.nodepair[1] === lkb.nodepair[0]);
        };
        enhanced_equlink = function(lka, lkb) {
          return (lka.nodepair[0] === lkb.nodepair[0] && lka.nodepair[1] === lkb.nodepair[1] && lka.blocked === lkb.blocked) || (lka.nodepair[0] === lkb.nodepair[1] && lka.nodepair[1] === lkb.nodepair[0] && lka.blocked === lkb.blocked);
        };
        _fn = function(d) {
          var o;
          if (d.node != null) {
            o = {
              mac: d.node.local_id,
              ip: d.node.local_ip_address,
              location: d.node.sys_location,
              name: d.node.sys_name,
              rings: []
            };
            return gnodes.push(o);
          }
        };
        for (_i = 0, _len = devs.length; _i < _len; _i++) {
          d = devs[_i];
          _fn(d);
        }
        for (_j = 0, _len1 = devs.length; _j < _len1; _j++) {
          d = devs[_j];
          blkports = [];
          upports = [];
          if (d.ports != null) {
            blkports = (function() {
              var _k, _len2, _ref, _results;
              _ref = d.ports;
              _results = [];
              for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                p = _ref[_k];
                if (p.blocking) {
                  _results.push(p.no);
                }
              }
              return _results;
            })();
            upports = (function() {
              var _k, _len2, _ref, _results;
              _ref = d.ports;
              _results = [];
              for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                p = _ref[_k];
                if (p.link === 'up') {
                  _results.push(p.no);
                }
              }
              return _results;
            })();
          }
          if (d.links != null) {
            _ref = d.links;
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              l = _ref[_k];
              if (_ref1 = l.local_port_no, __indexOf.call(upports, _ref1) < 0) {
                continue;
              }
              if (find_node_idx(l.neighbour_id) < 0) {
                gnodes.push({
                  mac: l.neighbour_id,
                  ip: l.neighbour_ip_address,
                  location: 'unknown',
                  name: l.neighbour_system_name
                });
              }
              link = {
                nodepair: [find_node_idx(l.local_id), find_node_idx(l.neighbour_id)],
                portpair: [l.local_port_no, l.neighbour_port_no],
                blocked: (_ref2 = l.local_port_no, __indexOf.call(blkports, _ref2) >= 0)
              };
              add_to_linkset(glinks, link);
              find_dup_n(glinks);
            }
          }
        }
        for (_l = 0, _len3 = devs.length; _l < _len3; _l++) {
          d = devs[_l];
          if (d.rings == null) {
            continue;
          }
          _ref3 = d.rings;
          for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
            r = _ref3[_m];
            if (grings[r.ring_id] == null) {
              grings[r.ring_id] = {
                id: r.ring_id,
                type: r.type,
                state: r.state,
                nodes: [],
                links: []
              };
            }
            mring = grings[r.ring_id];
            if (d.node != null) {
              mring.nodes.push({
                idx: find_node_idx(d.node.local_id),
                role: r.role
              });
            }
            if (d.node != null) {
              linkidx = find_linkidx(d.node.local_id, r.ring_port_0);
            }
            if (linkidx != null) {
              if (__indexOf.call(mring.links, linkidx) < 0) {
                mring.links.push(linkidx);
              }
            }
            if (d.node != null) {
              linkidx = find_linkidx(d.node.local_id, r.ring_port_1);
            }
            if (linkidx != null) {
              if (__indexOf.call(mring.links, linkidx) < 0) {
                mring.links.push(linkidx);
              }
            }
          }
        }
        for (rid in grings) {
          ring = grings[rid];
          _ref4 = ring.nodes;
          for (_n = 0, _len5 = _ref4.length; _n < _len5; _n++) {
            rnode = _ref4[_n];
            node = gnodes[rnode.idx];
            node.rings.push({
              id: ring.id,
              type: ring.type,
              role: rnode.role
            });
          }
          _ref5 = ring.links;
          for (_o = 0, _len6 = _ref5.length; _o < _len6; _o++) {
            rlinkidx = _ref5[_o];
            link = glinks[rlinkidx];
            if (link.rings == null) {
              link.rings = [];
            }
            link.rings.push({
              id: ring.id,
              type: ring.type
            });
          }
        }
        return {
          nodes: gnodes,
          links: glinks,
          rings: grings
        };
      }
    };
  });

  ngapp.service('msgbox', function($rootScope) {
    return {
      msgbar_show: function(msg, type, x, y) {
        if ((msg != null) && (type != null)) {
          console.log(type + ': ' + msg);
          d3.select('.message-type').classed('success', false);
          d3.select('.message-type').classed('error', false);
          d3.select('.message-type').classed('instruction', false);
          d3.select('.message-type').classed('info', false);
          d3.select('.message-type').text(type);
          d3.select('.message').text(msg);
          switch (type) {
            case 'success':
              d3.select('#noti').transition().style('opacity', 1).duration(200).transition().style('opacity', 0).duration(10000);
              d3.select('.message-type').classed('success', true);
              break;
            case 'error':
              d3.select('#noti').transition().style('opacity', 1).duration(200).transition().style('opacity', 0).duration(25000);
              d3.select('.message-type').classed('error', true);
              break;
            case 'instruction':
              d3.select('#noti').transition().style('opacity', 1).duration(200).transition().style('opacity', 0).duration(30000);
              d3.select('.message-type').classed('instruction', true);
              break;
            case 'info':
              d3.select('#noti').transition().style('opacity', 1).duration(200).transition().style('opacity', 0).duration(50000);
              d3.select('.message-type').classed('info', true);
          }
        }
        if ((x != null) && (y != null)) {
          return console.log('start pointer');
        }
      }
    };
  });

  ngapp.controller('loading', function($scope, $rootScope, smith, $timeout) {
    $scope.page = '';
    $scope.reload = function() {
      return win.reload();
    };
    $scope.showdev = function() {
      return win.showDevTools();
    };
    $scope.reloadtopo = function() {
      $scope.page = ' ';
      $timeout((function() {
        return $scope.page = 'topology';
      }), 400);
      return $timeout((function() {
        return d3.select('#menubar').transition().style({
          top: 700 + 'px',
          opacity: 0
        }).duration(2000);
      }), 800);
    };
    $scope.$watch('testconfigs', function(newone, oldone) {
      if (newone === true) {
        window.targetip = ['192.168.16.12', '192.168.16.13'];
        window.agent_start();
        $rootScope.showconfigs = true;
        window.smith_reconnect = true;
      }
      if (newone === false) {
        window.targetip = [];
        $rootScope.showconfigs = false;
        return window.smith_reconnect = false;
      }
    });
    $scope.$watch('config', function(newone, oldone) {
      if (newone !== void 0 && $scope.smith_not_connected === false) {
        $scope.config = newone;
      }
      if (newone !== void 0 && $scope.smith_not_connected === true) {
        return $scope.$watch('smith_not_connected', function(newstatus, oldstatus) {
          if (newstatus === false) {
            $scope.config = '';
            return $scope.config = newone;
          }
        });
      }
    });
    $scope.list_device = function() {
      return console.log(window.mr.network_devices_list());
    };
    $scope.test_muticast_send = function() {
      var msg;
      msg = {
        key: 'intrising',
        type: 'api',
        mac: '28:60:46:a0:07:d5',
        api: {
          name: 'system::set_sys_cfg',
          args: {
            location: '12dsfsdf34'
          }
        }
      };
      return window.mr.mcastsend(msg, window["interface"]);
    };
    return $scope.start_muticast = function() {
      return window.mr.start_mcast_receiver(window["interface"]);
    };
  });

  ngapp.directive('demo', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/demo.html',
      scope: {},
      controller: function($scope, $http, $q, $rootScope, topo, msgbox, effect) {
        var draw_topology, error, getdata, reconstruct_topology_data, set_for_selection, topo_json;
        $rootScope.showconfigs = false;
        window.smith_reconnect = false;
        effect.hide_spinner();
        clearInterval(window.regular_checking);
        clearInterval(window.regular_rechecking);
        topo_json = 'ringtops.json';
        getdata = function(json_url) {
          return $http.get(json_url).success(function(data) {});
        };
        set_for_selection = function(http_get_data) {
          var rawdata, top, topnm;
          rawdata = http_get_data.data;
          $scope.topnms = (function() {
            var _results;
            _results = [];
            for (topnm in rawdata) {
              top = rawdata[topnm];
              _results.push(topnm);
            }
            return _results;
          })();
          $scope.topcap = function(topnm) {
            return topnm.replace(/_/g, ' ');
          };
          $("#selection").chosen({
            no_results_text: "No results match",
            max_selected_options: 1,
            width: "160px"
          });
          setTimeout((function() {
            return $("#selection").trigger("chosen:updated");
          }), 1500);
          return http_get_data;
        };
        reconstruct_topology_data = function(http_get_data) {
          var complete_topd, target_topo, topodata;
          topodata = http_get_data.data;
          complete_topd = function(topd) {
            var lidx, link, node, nrd, rid, ringd, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _results;
            _ref = topd.nodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              node.rings = [];
            }
            _ref1 = topd.links;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              link = _ref1[_j];
              link.rings = [];
            }
            _ref2 = topd.rings;
            _results = [];
            for (rid in _ref2) {
              ringd = _ref2[rid];
              _ref3 = ringd.links;
              for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                lidx = _ref3[_k];
                link = topd.links[lidx];
                if (link.rings == null) {
                  link.rings = [];
                }
                link.rings.push({
                  id: ringd.id,
                  type: ringd.type
                });
              }
              _results.push((function() {
                var _l, _len3, _ref4, _results1;
                _ref4 = ringd.nodes;
                _results1 = [];
                for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
                  nrd = _ref4[_l];
                  node = topd.nodes[nrd.idx];
                  if (node.rings == null) {
                    node.rings = [];
                  }
                  _results1.push(node.rings.push({
                    id: ringd.id,
                    type: ringd.type,
                    role: nrd.role
                  }));
                }
                return _results1;
              })());
            }
            return _results;
          };
          target_topo = topodata[$scope.seltopnm];
          complete_topd(target_topo);
          return target_topo;
        };
        draw_topology = function(topodata) {
          if (topodata != null) {
            return topo.showd3(topodata, 'demo', null, 'ring');
          } else {
            return $q.reject('data not ready');
          }
        };
        error = function(err) {
          return msgbox.msgbar_show(err, 'error');
        };
        $scope.q_starttopo = function() {
          var deferred, promise;
          deferred = $q.defer();
          promise = deferred.promise;
          promise.then(getdata).then(set_for_selection).then(reconstruct_topology_data).then(draw_topology, error);
          return deferred.resolve(topo_json);
        };
        return $scope.q_starttopo();
      }
    };
  });

  ngapp.directive('testing100', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/demo.html',
      scope: {},
      controller: function($scope, $http, $q, $rootScope, topo, msgbox, effect, smith, data) {
        $rootScope.showconfigs = false;
        window.smith_reconnect = true;
        effect.hide_spinner('Scanning');
        clearInterval(window.regular_checking);
        clearInterval(window.regular_rechecking);
        return $http.get('wonju_topd.json').success(function(topd) {
          var dev, good, ip, raw;
          raw = (function() {
            var _results;
            _results = [];
            for (ip in topd) {
              dev = topd[ip];
              _results.push(dev);
            }
            return _results;
          })();
          good = data.processer(raw);
          return topo.showd3(good, 'scan', 'set_ip', 'ring');
        });
      }
    };
  });

  ngapp.directive('testing', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/demo.html',
      scope: {},
      controller: function($scope, $http, $q, $rootScope, topo, msgbox, effect, smith) {
        var draw_topology, error, getdata, reconstruct_topology_data, set_for_selection, topo_json;
        $rootScope.showconfigs = false;
        window.smith_reconnect = true;
        effect.hide_spinner('Scanning');
        clearInterval(window.regular_checking);
        clearInterval(window.regular_rechecking);
        topo_json = 'ringtops.json';
        getdata = function(json_url) {
          return $http.get(json_url).success(function(data) {});
        };
        set_for_selection = function(http_get_data) {
          var rawdata, top, topnm;
          rawdata = http_get_data.data;
          $scope.topnms = (function() {
            var _results;
            _results = [];
            for (topnm in rawdata) {
              top = rawdata[topnm];
              _results.push(topnm);
            }
            return _results;
          })();
          $scope.topcap = function(topnm) {
            return topnm.replace(/_/g, ' ');
          };
          return http_get_data;
        };
        reconstruct_topology_data = function(http_get_data) {
          var complete_topd, target_topo, topodata;
          topodata = http_get_data.data;
          complete_topd = function(topd) {
            var lidx, link, node, nrd, rid, ringd, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _results;
            _ref = topd.nodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              node.rings = [];
            }
            _ref1 = topd.links;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              link = _ref1[_j];
              link.rings = [];
            }
            _ref2 = topd.rings;
            _results = [];
            for (rid in _ref2) {
              ringd = _ref2[rid];
              _ref3 = ringd.links;
              for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                lidx = _ref3[_k];
                link = topd.links[lidx];
                if (link.rings == null) {
                  link.rings = [];
                }
                link.rings.push({
                  id: ringd.id,
                  type: ringd.type
                });
              }
              _results.push((function() {
                var _l, _len3, _ref4, _results1;
                _ref4 = ringd.nodes;
                _results1 = [];
                for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
                  nrd = _ref4[_l];
                  node = topd.nodes[nrd.idx];
                  if (node.rings == null) {
                    node.rings = [];
                  }
                  _results1.push(node.rings.push({
                    id: ringd.id,
                    type: ringd.type,
                    role: nrd.role
                  }));
                }
                return _results1;
              })());
            }
            return _results;
          };
          target_topo = topodata[$scope.seltopnm];
          complete_topd(target_topo);
          return target_topo;
        };
        draw_topology = function(topodata) {
          if (topodata != null) {
            return topo.showd3(topodata, 'scan', 'set_ip', 'ring');
          } else {
            return $q.reject('data not ready');
          }
        };
        error = function(err) {
          return msgbox.msgbar_show(err, 'error');
        };
        $scope.q_starttopo = function() {
          var deferred, promise;
          deferred = $q.defer();
          promise = deferred.promise;
          promise.then(getdata).then(set_for_selection).then(reconstruct_topology_data).then(draw_topology, error);
          return deferred.resolve(topo_json);
        };
        return $scope.q_starttopo();
      }
    };
  });

  ngapp.directive('topology', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/topology.html',
      scope: {},
      controller: function($rootScope, $scope, $q, $timeout, data, topo, smith, msgbox, effect) {
        var go;
        $rootScope.showconfigs = false;
        window.smith_reconnect = false;
        go = function() {
          var checkdata, draw_topology, recheckdata, reset_topology, test_empty, test_ip, test_ring, test_structure;
          $scope.data = {};
          $scope.device_list = {};
          msgbox.msgbar_show('start to scan device on lan', 'info');
          effect.show_spinner('Scanning');
          window.mr.start_mcast_receiver(window["interface"]);
          test_structure = function(obj) {
            if (_.has(obj, 'ports') === true && _.has(obj, 'links') === true && _.has(obj, 'node') === true && _.has(obj, 'rings') === true) {
              return true;
            } else {
              return false;
            }
          };
          test_empty = function(obj) {
            if (_.isEmpty(obj) === false) {
              return true;
            } else {
              return false;
            }
          };
          test_ip = function(obj) {
            if (_.has(obj, 'ip')) {
              return true;
            } else {
              return false;
            }
          };
          test_ring = function(obj) {
            if (obj.id != null) {
              return true;
            } else {
              return false;
            }
          };
          recheckdata = function() {
            var dev, ip, new_topodata, new_topodata_noring, newraw;
            msgbox.msgbar_show('rescanning...', 'info');
            window.mr.start_mcast_receiver(window["interface"]);
            newraw = (function() {
              var _ref, _results;
              _ref = window.mr.swnodes;
              _results = [];
              for (ip in _ref) {
                dev = _ref[ip];
                _results.push(dev);
              }
              return _results;
            })();
            $scope.device_list = window.mr.network_devices_list();
            $scope.$apply();
            new_topodata = data.processer(newraw);
            new_topodata_noring = _.omit(new_topodata, 'rings');
            if (_.every(new_topodata_noring, test_empty) === true) {
              $scope.data = new_topodata;
              return $scope.$apply();
            }
          };
          reset_topology = function() {
            d3.select('#panel').style('opacity', 0);
            d3.select('#panelsvg').remove();
            d3.select('#panelselectionwrap').remove();
            d3.selectAll('.lsslct').remove();
            d3.selectAll('.lslink').remove();
            d3.selectAll('.ip_list').remove();
            d3.selectAll('.iplslink').remove();
            d3.select('#ip_panel').remove();
            d3.selectAll('.link').remove();
            d3.selectAll('.node').remove();
            d3.selectAll(".nodetext").remove();
            return d3.select('.inhibit').remove();
          };
          $scope.$watch('data', function(new_data, old_data) {
            var ck_link, ck_link_blocked, ck_node, ck_node_rings, ck_ring_d;
            ck_node_rings = function() {
              var new_node_ring, new_node_ring_o, old_node_ring, old_node_ring_o;
              new_node_ring = _.map(new_data.nodes, function(value, key, list) {
                return value.rings;
              });
              new_node_ring_o = _.reject(new_node_ring, function(n) {
                return n === void 0;
              });
              old_node_ring = _.map(old_data.nodes, function(value, key, list) {
                return value.rings;
              });
              old_node_ring_o = _.reject(old_node_ring, function(n) {
                return n === void 0;
              });
              if (angular.equals(new_node_ring_o, old_node_ring_o) !== true) {
                console.log('nodes.rings change detected.');
                return true;
              } else {
                return false;
              }
            };
            ck_link_blocked = function() {
              var d, new_link_blocked, old_link_blocked;
              new_link_blocked = _.map(new_data.links, function(value, key, list) {
                return value.blocked;
              });
              old_link_blocked = _.map(old_data.links, function(value, key, list) {
                return value.blocked;
              });
              d = _.difference(new_link_blocked, old_link_blocked);
              if (_.size(d) === 0) {
                return false;
              } else {
                console.log('links.blocked status change detected.');
                return true;
              }
            };
            ck_ring_d = function() {
              var d, new_ring_state, old_ring_state;
              new_ring_state = _.map(new_data.rings, function(e) {
                return e.state;
              });
              old_ring_state = _.map(old_data.rings, function(e) {
                return e.state;
              });
              d = _.difference(new_ring_state, old_ring_state);
              if (_.size(d) === 0) {
                return false;
              } else {
                console.log('rings.state status change detected.');
                return true;
              }
            };
            ck_node = function() {
              if ((new_data.nodes != null) && (old_data.nodes != null)) {
                if (new_data.nodes.length !== old_data.nodes.length) {
                  console.log('new node deteted');
                  return true;
                } else {
                  return false;
                }
              } else {
                return false;
              }
            };
            ck_link = function() {
              if ((new_data.links != null) && (old_data.links != null)) {
                if (new_data.links.length !== old_data.links.length) {
                  console.log('new link detected');
                  return true;
                } else {
                  return false;
                }
              } else {
                return false;
              }
            };
            if (ck_node() || ck_link() || ck_ring_d() || ck_node_rings() || ck_link_blocked()) {
              msgbox.msgbar_show('new data fetched. topology changes', 'info');
              return draw_topology(new_data);
            }
          });
          $scope.$watch('device_list', function(new_data, old_data) {
            var ck_d, time;
            time = 0;
            if (_.size(new_data) > 0 && _.size(old_data) > 0) {
              ck_d = function() {
                var d1, d2;
                d1 = _.difference(_.keys(new_data), _.keys(old_data));
                d2 = _.difference(_.keys(old_data), _.keys(new_data));
                if (_.size(d1) === 0 && _.size(d2) === 0) {
                  return false;
                } else {
                  return true;
                }
              };
              if (ck_d() === true) {
                msgbox.msgbar_show('network device changed, topology redraw', 'info');
                effect.show_spinner('Scanning');
                clearInterval(window.regular_checking);
                clearInterval(window.regular_rechecking);
                reset_topology();
                window.mr.start_mcast_receiver(window["interface"]);
                window.mr.swnodes = {};
                window.regular_checking = setInterval(checkdata, 5000);
                return time = time + 1;
              }
            } else if (time = 1) {
              msgbox.msgbar_show('no connection found, please check you network connections. auto retry in 3 seconds...', 'info');
              effect.show_spinner('Scanning');
              clearInterval(window.regular_checking);
              clearInterval(window.regular_rechecking);
              reset_topology();
              window.mr.start_mcast_receiver(window["interface"]);
              window.mr.swnodes = {};
              return window.regular_checking = setInterval(checkdata, 5000);
            }
          });
          checkdata = function() {
            var dev, ip, raw, topodata, topodata_noring;
            $scope.device_list = window.mr.network_devices_list();
            $scope.$apply();
            raw = (function() {
              var _ref, _results;
              _ref = window.mr.swnodes;
              _results = [];
              for (ip in _ref) {
                dev = _ref[ip];
                _results.push(dev);
              }
              return _results;
            })();
            topodata = data.processer(raw);
            topodata_noring = _.omit(topodata, ['rings', 'links']);
            if (_.every(topodata_noring, test_empty) === true) {
              msgbox.msgbar_show('initial scaning complete', 'success');
              clearInterval(window.regular_checking);
              draw_topology(topodata_noring);
              window.regular_rechecking = setInterval(recheckdata, 4000);
              $scope.data = topodata_noring;
              $scope.$apply();
              return effect.hide_spinner();
            } else {
              msgbox.msgbar_show('collecting data from devices...', 'info');
              if (raw.length === 0) {
                msgbox.msgbar_show('no device found', 'info');
              }
              window.mr.start_mcast_receiver(window["interface"]);
              return effect.show_spinner('Scanning');
            }
          };
          draw_topology = function(topodata) {
            if (_.every(topodata.rings, test_ring) === true) {
              topo.showd3(topodata, 'scan', 'set_ip', 'ring');
              console.log('ring mode');
            }
            if (_.every(topodata.rings, test_ring) === false) {
              topo.showd3(topodata, 'scan', 'set_ip', 'phy');
              return console.log('phy mode');
            }
          };
          return window.regular_checking = setInterval(checkdata, 5000);
        };
        window["interface"] = null;
        $scope.done = false;
        $scope.network_ip_list = window.mr.network_ip_list();
        msgbox.msgbar_show('Please select your network interface', 'info');
        setTimeout((function() {
          return $("#interface_selection").chosen({
            disable_search: true,
            max_selected_options: 1,
            width: "180px"
          });
        }), 20);
        $scope.interface_selected = function() {
          window["interface"] = $scope.$$childHead["interface"].address;
          if (window["interface"] !== null) {
            go();
            return $scope.done = true;
          }
        };
        if ($scope.network_ip_list.length === 1) {
          return go();
        }
      }
    };
  });

  ngapp.directive('ipconf', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/ip_conf.html',
      scope: {},
      controller: function($scope, $timeout, smith, msgbox, compare) {
        $scope.doapply = function() {
          smith.emit('system::set_net_cfg', $scope.cfg);
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 2000);
        };
        return smith.emit('system::get_net_cfg', function(cfg) {
          var agent, k, ncfg, _i, _len, _ref;
          ncfg = {};
          _ref = ['netmask', 'dnsip'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            k = _ref[_i];
            ncfg[k] = cfg[k];
          }
          $scope.cfg = ncfg;
          $scope.$apply();
          agent = this;
          compare.pushdata(agent, 'ipconf', ncfg);
          return compare.compare(agent, 'ipconf');
        });
      }
    };
  });

  ngapp.directive('xringconf', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/xring_conf.html',
      scope: {},
      controller: function($rootScope, $scope, smith, data, msgbox, compare, $timeout) {
        compare.init();
        $scope.available_ring_mode = {
          'basic': 'basic',
          'enhanced': 'enhanced',
          'auto': 'auto'
        };
        smith.emit('system::get_sys_cfg', function(cfg) {
          $scope.ring_mode = cfg.ring_mode;
          $scope.$apply();
          return setTimeout((function() {
            return $("#ring_mode").chosen({
              disable_search: true,
              max_selected_options: 1,
              width: "160px"
            });
          }), 200);
        });
        $scope.rings = [];
        smith.emit('g8032::get_member_cfg', function(rings) {
          var agent;
          $scope.rings = rings;
          $scope.$apply();
          agent = this;
          compare.pushdata(agent, 'ring', rings);
          return compare.compare(agent, 'ring');
        });
        $scope.doapply = function() {
          var getoldring, ipppp, setnewring;
          setnewring = function() {
            var index, oldring, ring, _fn, _i, _j, _len, _len1, _ref, _ref1;
            if ($scope.ring_mode === void 0 && $scope.rings.length > 0) {
              msgbox.msgbar_show('Please set ring mode...', 'error');
              $scope.applying = true;
              return $timeout((function() {
                return $scope.applying = false;
              }), 500);
            } else {
              msgbox.msgbar_show('Please wait for few seconds...', 'info');
              _ref = $scope.old;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                oldring = _ref[_i];
                smith.emit('g8032::leave_ring_member_cfg', oldring);
              }
              _ref1 = $scope.rings;
              _fn = function(ring, index) {
                var n;
                switch ($scope.ringmode) {
                  case 'auto':
                    ring.role = 'none';
                    ring.node_fail_protection = false;
                    break;
                  case 'basic':
                    ring.miss_connection_enabled = false;
                }
                n = $scope.rings.length - 1;
                if (index === n) {
                  smith.emit('g8032::delay_join_ring_member_cfg', $scope.rings);
                  return $timeout((function() {
                    var cfg;
                    cfg = {
                      'ring_mode': $scope.ring_mode
                    };
                    return smith.emit('system::delay_set_sys_cfg', cfg);
                  }), 2000);
                }
              };
              for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
                ring = _ref1[index];
                _fn(ring, index);
              }
              $scope.applying = true;
              return $timeout((function() {
                return $scope.applying = false;
              }), 8000);
            }
          };
          $scope.old = [];
          ipppp = [];
          getoldring = function() {
            return smith.emit('g8032::get_member_cfg', function(oldrings) {
              var agent;
              $scope.old.push(oldrings);
              $scope.$apply();
              agent = this;
              if (agent.transport != null) {
                ipppp.push(agent.transport.input.remoteAddress);
              }
              if (ipppp.length === window.agent.length) {
                return setnewring();
              }
            });
          };
          return getoldring();
        };
        $scope.ringchg = function() {
          if (this.cfg.enabled) {
            if (this.cfg.ring_port_0 === -1) {
              this.cfg.ring_port_0 = 3;
            }
            if (this.cfg.ring_port_1 === -1) {
              this.cfg.ring_port_1 = 4;
            }
            if (this.cfg.ring_id === -1) {
              return this.cfg.ring_id = 100;
            }
          }
        };
        $scope.portcap = function(pno) {
          return "Port " + pno;
        };
        $scope.yesnocap = function(b) {
          if (b) {
            return 'YES';
          } else {
            return 'NO';
          }
        };
        $scope.enablecap = function(b) {
          if (b) {
            return 'on';
          } else {
            return 'off';
          }
        };
        $scope.availports = function() {
          var port, ring, used, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
          used = [];
          _ref = $scope.rings;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            ring = _ref[_i];
            used.push(ring.ring_port_0, ring.ring_port_1);
          }
          used = _.union(used, this.stpports);
          _ref1 = this.ports;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            port = _ref1[_j];
            if (_ref2 = port.no, __indexOf.call(used, _ref2) < 0) {
              _results.push(port.no);
            }
          }
          return _results;
        };
        $scope.editing_invalid = function() {
          var epair, er, i, othpair, r, _i, _len, _ref;
          er = this.editing_ring;
          if (er == null) {
            return true;
          }
          if (er.ring_port_0 === er.ring_port_1) {
            return true;
          }
          if (er.type === 'sub') {
            return false;
          }
          epair = [er.ring_port_0, er.ring_port_1];
          _ref = this.rings;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            r = _ref[i];
            if (!(i !== this.editing_idx)) {
              continue;
            }
            if (Number(er.ring_id) === Number(r.ring_id)) {
              return true;
            }
            othpair = [r.ring_port_0, r.ring_port_1];
          }
          return false;
        };
        $scope.rolecaps = {
          none: "None",
          owner: "Owner",
          neighbour: "Neighbour"
        };
        $scope.typecaps = {
          sub: "Sub",
          major: "Major"
        };
        $scope.editing_idx = -1;
        $scope.newid = function() {
          var max, ring, _i, _len, _ref;
          max = 0;
          _ref = this.rings;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            ring = _ref[_i];
            if (ring.ring_id > max) {
              max = ring.ring_id;
            }
          }
          return max + 1;
        };
        $scope.add_ring = function() {
          var aports;
          aports = this.availports();
          if (aports.length < 1) {
            msgbox.msgbar_show('no ports are available for ring', 'error');
            return;
          }
          return this.rings.push({
            enabled: false,
            role: 'none',
            type: 'major',
            ring_id: $scope.newid(),
            ring_port_0: aports[0],
            ring_port_1: aports[1]
          });
        };
        $scope.del_ring = function(rid) {
          var r;
          return $scope.rings = (function() {
            var _i, _len, _ref, _results;
            _ref = this.rings;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              r = _ref[_i];
              if (r.ring_id !== rid) {
                _results.push(r);
              }
            }
            return _results;
          }).call(this);
        };
        $scope.switch_to_editing = function(idx) {
          var aports, port, r;
          $scope.editing = true;
          $scope.editing_ring = r = angular.copy($scope.rings[idx]);
          aports = (function() {
            var _i, _len, _ref, _ref1, _results;
            _ref = this.ports;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              port = _ref[_i];
              if (_ref1 = port.no, __indexOf.call(this.stpports, _ref1) < 0) {
                _results.push(port.no);
              }
            }
            return _results;
          }).call(this);
          $scope.editing_aports = aports;
          $scope.editing_idx = idx;
          return setTimeout((function() {
            $(".ringselect_port").chosen({
              disable_search: true,
              max_selected_options: 1,
              width: "75px"
            });
            return $(".ringselect").chosen({
              disable_search: true,
              max_selected_options: 1,
              width: "78px"
            });
          }), 200);
        };
        $scope.port0msg = function() {
          if (this.editing_ring == null) {
            return '';
          }
          if (this.editing_ring.role === 'neighbour') {
            return 'the RPL Port to Major';
          }
          if (this.editing_ring.role === 'owner') {
            return 'the RPL Port to Neighbor';
          }
          return '';
        };
        $scope.edit_cancel = function() {
          $scope.editing = false;
          return $scope.editing_idx = -1;
        };
        $scope.edit_save = function() {
          $scope.editing = false;
          $scope.rings[this.editing_idx] = this.editing_ring;
          return $scope.editing_idx = -1;
        };
        $scope.automode = false;
        $scope.allports_occupied = false;
        smith.emit('port_ctrl::get_status', function(cfg) {
          $scope.ports = cfg;
          return $scope.$apply();
        });
        $scope.checkdualhoming = function() {
          return smith.emit('dualhoming::get_member_cfg', function(cfg) {
            var agent, x, _i, _len, _results;
            agent = this;
            _results = [];
            for (_i = 0, _len = cfg.length; _i < _len; _i++) {
              x = cfg[_i];
              if (x.port_no && x.enabled) {
                $scope.stpports.push(x.port_no);
                _results.push($scope.$apply());
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
        };
        return smith.emit('mstp::get_cist_cfg', function(cistg) {
          var cp;
          if (cistg.ports != null) {
            $scope.stpports = (function() {
              var _i, _len, _ref, _results;
              _ref = cistg.ports;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                cp = _ref[_i];
                if (cp.stp_enabled) {
                  _results.push(cp.no);
                }
              }
              return _results;
            })();
          }
          $scope.allports_occupied = ($scope.rings.length === 0) && ($scope.availports().length === 0);
          $scope.$apply();
          return $scope.checkdualhoming();
        });
      }
    };
  });

  ngapp.directive('evleventsddmev', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/evlevents_ddmev.html',
      scope: {},
      controller: function($scope, smith, msgbox, compare, $timeout) {
        var dBm_to_uW, uW_to_dBm;
        compare.init();
        uW_to_dBm = function(uw) {
          return 10 * Math.log(Number(uw) / 1000) / Math.LN10;
        };
        dBm_to_uW = function(dbm) {
          return 1000 * Math.pow(10, Number(dbm) / 10);
        };
        $scope.ready = false;
        $scope.doapply = function() {
          var cfg, thr;
          cfg = angular.copy($scope.cfg);
          thr = cfg.thresholds;
          thr.tx_power[0] = dBm_to_uW(thr.tx_power[0]);
          thr.tx_power[1] = dBm_to_uW(thr.tx_power[1]);
          thr.rx_power[0] = dBm_to_uW(thr.rx_power[0]);
          thr.rx_power[1] = dBm_to_uW(thr.rx_power[1]);
          smith.emit('hwevent::set_config', {
            ddm: cfg
          });
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 1000);
        };
        $scope.vccfmt = function(value) {
          if (value != null) {
            return value.toString() + "V";
          }
        };
        $scope.dbmfmt = function(value) {
          if (value != null) {
            return Math.floor(value).toString() + "dBm";
          }
        };
        $scope.tempfmt = function(value) {
          if (value != null) {
            return value.toString() + "\u2103";
          }
        };
        $scope.biasfmt = function(value) {
          if (value != null) {
            return value.toString() + "mA";
          }
        };
        return smith.emit('hwevent::get_config', function(allcfg) {
          var agent, cfg, thr;
          cfg = allcfg.ddm;
          thr = cfg.thresholds;
          thr.tx_power[0] = uW_to_dBm(thr.tx_power[0]);
          thr.tx_power[1] = uW_to_dBm(thr.tx_power[1]);
          thr.rx_power[0] = uW_to_dBm(thr.rx_power[0]);
          thr.rx_power[1] = uW_to_dBm(thr.rx_power[1]);
          $scope.cfg = cfg;
          agent = this;
          compare.pushdata(agent, 'evleventsddmev', cfg);
          compare.compare(agent, 'evleventsddmev');
          $scope.ready = true;
          return $scope.$apply();
        });
      }
    };
  });

  ngapp.directive('systemlogsmtpcconf', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/systemlog_smtpc_conf.html',
      scope: {},
      controller: function($scope, smith, msgbox, compare, $timeout) {
        var theform_valid;
        compare.init();
        theform_valid = function() {
          return true;
        };
        $scope.appliable = function() {
          if (this.smtpc == null) {
            return false;
          }
          if (this.smtpc.enabled) {
            if (!theform_valid()) {
              return false;
            }
          }
          return true;
        };
        $scope.doapply = function() {
          smith.emit('evact_manager::set_smtp_cfg', $scope.smtpc);
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 1000);
        };
        $scope.email_toadd = '';
        $scope.smtpc_add_receiver = function(email) {
          if (email === '') {
            msgbox.msgbar_show('empty input', 'error');
          } else {
            if (__indexOf.call(this.smtpc.receivers, email) >= 0) {
              msgbox.msgbar_show('email address duplicated', 'error');
            } else {
              this.smtpc.receivers.push(email);
            }
          }
          return $scope.email_toadd = '';
        };
        $scope.smtpc_dotest = function(rcver) {
          smith.emit('evact_manager::smtp_test', rcver);
          return msgbox.msgbar_show('Test Email Sent', 'success');
        };
        $scope.smtpc_del_receiver = function(rcver) {
          var i, r, receivers, _i, _len, _results;
          receivers = this.smtpc.receivers;
          _results = [];
          for (i = _i = 0, _len = receivers.length; _i < _len; i = ++_i) {
            r = receivers[i];
            if (r === rcver) {
              _results.push(receivers.splice(i, 1));
            }
          }
          return _results;
        };
        smith.emit('evact_manager::get_smtp_cfg', function(cfg) {
          var agent;
          if (cfg.cloud_smtp == null) {
            cfg.cloud_smtp = true;
          }
          $scope.smtpc = cfg;
          $scope.$apply();
          agent = this;
          compare.pushdata(agent, 'systemlogsmtpcconf', cfg);
          return compare.compare(agent, 'systemlogsmtpcconf');
        });
        return $('ul.typeahead').mousedown(function(e) {
          return e.preventDefault();
        });
      }
    };
  });

  ngapp.directive('systemlogsmscconf', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/systemlog_smsc_conf.html',
      scope: {},
      controller: function($scope, smith, msgbox, compare, $timeout) {
        var theform_valid;
        compare.init();
        theform_valid = function() {
          var valid;
          return valid = true;
        };
        $scope.appliable = function() {
          if (this.smsc == null) {
            return false;
          }
          if (this.smsc.enabled) {
            if (!theform_valid()) {
              return false;
            }
            if (this.smsc.receivers.length === 0) {
              return false;
            }
          }
          return true;
        };
        $scope.doapply = function() {
          smith.emit('evact_manager::set_sms_cfg', this.smsc);
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 1000);
        };
        $scope.phoneno_toadd = '';
        $scope.smsc_add_receiver = function(phoneno) {
          if (phoneno == null) {
            return;
          }
          if (__indexOf.call(this.smsc.receivers, phoneno) >= 0) {
            msgbox.msgbar_show('Phone number duplicated', 'error');
            return;
          }
          this.smsc.receivers.push(phoneno);
          return $scope.phoneno_toadd = '';
        };
        $scope.smsc_del_receiver = function(rcver) {
          var i, r, receivers, _i, _len, _results;
          receivers = this.smsc.receivers;
          _results = [];
          for (i = _i = 0, _len = receivers.length; _i < _len; i = ++_i) {
            r = receivers[i];
            if (r === rcver) {
              _results.push(receivers.splice(i, 1));
            }
          }
          return _results;
        };
        $scope.smsc_dotest = function(rcver) {
          smith.emit('evact_manager::sms_test', rcver);
          return msgbox.msgbar_show('SMS message sent');
        };
        return smith.emit('evact_manager::get_sms_cfg', function(cfg) {
          var agent;
          $scope.smsc = cfg;
          $scope.$apply();
          agent = this;
          compare.pushdata(agent, 'systemlogsmscconf', cfg);
          return compare.compare(agent, 'systemlogsmscconf');
        });
      }
    };
  });

  ngapp.directive('evlevactmap', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/evl_evactmap.html',
      scope: {},
      controller: function($rootScope, $scope, smith, data, msgbox, compare, $timeout) {
        var cfg_to_evas, defev, evas_to_cfg, events_enum, eventtab_load_cfg, eventtab_register_funcs, from_str, nports, to_str;
        compare.init();
        nports = {};
        from_str = function(s) {
          var nm, num, o, st, _ref;
          _ref = s.split('_'), nm = _ref[0], num = _ref[1], st = _ref[2];
          o = {
            name: nm
          };
          if (num != null) {
            o.no = Number(num);
          }
          if (st != null) {
            o.status = st;
          }
          return o;
        };
        to_str = function(ent) {
          var s;
          s = ent.name;
          if (ent.no != null) {
            s += "_" + ent.no;
          }
          if (ent.status != null) {
            s += "_" + ent.status;
          }
          return s;
        };
        evas_to_cfg = function(evas) {
          var actstr, cfg, ev, eva, evinst, _i, _len;
          cfg = {};
          for (_i = 0, _len = evas.length; _i < _len; _i++) {
            eva = evas[_i];
            ev = eva.ev;
            evinst = {};
            if (ev.no != null) {
              evinst.no = ev.no;
            }
            if (ev.status != null) {
              evinst.status = ev.status;
            }
            evinst.actions = (function() {
              var _j, _len1, _ref, _results;
              _ref = eva.acts;
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                actstr = _ref[_j];
                _results.push(from_str(actstr));
              }
              return _results;
            })();
            if (cfg[ev.name] == null) {
              cfg[ev.name] = [];
            }
            cfg[ev.name].push(evinst);
          }
          return cfg;
        };
        events_enum = function() {
          var dino, evnm, evs, p, pwno, st, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
          evs = [];
          _ref = ['boot', 'ddm', 'envmon', 'poe'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            evnm = _ref[_i];
            evs.push({
              name: evnm
            });
          }
          _ref1 = ['fail', 'success'];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            st = _ref1[_j];
            evs.push({
              name: 'auth',
              status: st
            });
          }
          for (dino = _k = 1; _k <= 2; dino = ++_k) {
            evs.push({
              name: 'di',
              no: dino
            });
          }
          for (pwno = _l = 1; _l <= 2; pwno = ++_l) {
            _ref2 = ['on', 'off'];
            for (_m = 0, _len2 = _ref2.length; _m < _len2; _m++) {
              st = _ref2[_m];
              evs.push({
                name: "power",
                no: pwno,
                status: st
              });
            }
          }
          for (_n = 0, _len3 = nports.length; _n < _len3; _n++) {
            p = nports[_n];
            _ref3 = ['up', 'down'];
            for (_o = 0, _len4 = _ref3.length; _o < _len4; _o++) {
              st = _ref3[_o];
              evs.push({
                name: "linkchg",
                no: p.no,
                status: st
              });
            }
          }
          return evs;
        };
        cfg_to_evas = function(evmcfg) {
          var act, evas, evinst, evinsts, evnm, evo, i, _i, _len;
          evas = [];
          for (evnm in evmcfg) {
            evinsts = evmcfg[evnm];
            for (i = _i = 0, _len = evinsts.length; _i < _len; i = ++_i) {
              evinst = evinsts[i];
              evo = _.pick(evinst, 'no', 'status');
              evo.name = evnm;
              evas.push({
                ev: evo,
                acts: (function() {
                  var _j, _len1, _ref, _results;
                  _ref = evinst.actions;
                  _results = [];
                  for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                    act = _ref[_j];
                    _results.push(to_str(act));
                  }
                  return _results;
                })()
              });
            }
          }
          return evas;
        };
        eventtab_register_funcs = function() {
          var actnmcaps, evnmcaps;
          $scope.doapply = function() {
            var cfg, diffcfg, evas, k, newv, origv, _i, _len, _ref;
            evas = $scope.curr_evas_norm.concat($scope.curr_evas_link);
            cfg = evas_to_cfg(evas);
            diffcfg = {};
            _ref = _.union(Object.keys(cfg), Object.keys($scope.origcfg));
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              k = _ref[_i];
              newv = cfg[k] != null ? cfg[k] : [];
              origv = $scope.origcfg[k];
              diffcfg[k] = newv;
            }
            smith.emit('evact_manager::set_event_cfg', diffcfg);
            $scope.applying = true;
            return $timeout((function() {
              return $scope.applying = false;
            }), 1000);
          };
          actnmcaps = {
            smtp: 'Email',
            remote: 'Syslog',
            snmp: 'SNMP Trap',
            dout: 'DOUT',
            sms: 'SMS'
          };
          $scope.actcap = function(actstr) {
            var actnm, actno, actst, cap, _ref;
            _ref = actstr.split('_'), actnm = _ref[0], actno = _ref[1], actst = _ref[2];
            cap = actnmcaps[actnm];
            if (actno != null) {
              cap += " " + actno;
            }
            if (actst != null) {
              cap += " " + actst;
            }
            return cap;
          };
          $scope.add_norm_event = function(ev) {
            $scope.curr_evas_norm.push({
              ev: ev,
              acts: ['remote']
            });
            return setTimeout((function() {
              $('#normev_form select').chosen();
              return $('#add_normev').trigger("chosen:updated");
            }), 0);
          };
          $scope.del_norm_event = function(ev_todel) {
            var eva;
            $scope.curr_evas_norm = (function() {
              var _i, _len, _ref, _results;
              _ref = $scope.curr_evas_norm;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                eva = _ref[_i];
                if (eva.ev !== ev_todel) {
                  _results.push(eva);
                }
              }
              return _results;
            })();
            $scope.normev_toadd = '';
            return setTimeout((function() {
              return $('#add_normev').trigger("chosen:updated");
            }), 0);
          };
          $scope.is_avail_norm_ev = function(ev) {
            var eva, _i, _len, _ref;
            _ref = $scope.curr_evas_norm;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              eva = _ref[_i];
              if (angular.equals(ev, eva.ev)) {
                return false;
              }
            }
            return true;
          };
          $scope.normev_toadd = '';
          $scope.add_link_event = function(ev) {
            $scope.curr_evas_link.push({
              ev: ev,
              acts: ['remote']
            });
            return setTimeout((function() {
              $('#linkev_form select').chosen();
              return $('#add_linkev').trigger("chosen:updated");
            }), 0);
          };
          $scope.del_link_event = function(ev_todel) {
            var eva;
            $scope.curr_evas_link = (function() {
              var _i, _len, _ref, _results;
              _ref = $scope.curr_evas_link;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                eva = _ref[_i];
                if (eva.ev !== ev_todel) {
                  _results.push(eva);
                }
              }
              return _results;
            })();
            $scope.linkev_toadd = '';
            return setTimeout((function() {
              return $('#add_linkev').trigger("chosen:updated");
            }), 0);
          };
          $scope.is_avail_link_ev = function(ev) {
            var eva, _i, _len, _ref;
            _ref = $scope.curr_evas_link;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              eva = _ref[_i];
              if (angular.equals(ev, eva.ev)) {
                return false;
              }
            }
            return true;
          };
          $scope.linkev_toadd = '';
          evnmcaps = {
            boot: 'Boot',
            auth: 'Login',
            di: 'DIN',
            power: 'Power',
            ring: 'Ring',
            linkchg: 'Port',
            ddm: 'DDM',
            envmon: 'EnvMon',
            poe: 'POE'
          };
          return $scope.evcap = function(ev) {
            var cap;
            cap = evnmcaps[ev.name];
            if ((ev.no != null) && (ev.status != null)) {
              cap += " " + ev.no + " " + ev.status;
            } else if (ev.no != null) {
              cap += " " + ev.no;
            } else if (ev.status != null) {
              cap += " " + ev.status;
            }
            return cap;
          };
        };
        eventtab_load_cfg = function($scope, evmcfg) {
          var allevs, ev, eva, evas;
          $scope.origcfg = evmcfg;
          evas = cfg_to_evas(evmcfg);
          allevs = events_enum();
          $scope.allacts = ['remote', 'smtp', 'sms', 'snmp', 'dout_1', 'dout_2'];
          $scope.norm_evs = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = allevs.length; _i < _len; _i++) {
              ev = allevs[_i];
              if (ev.name !== 'linkchg') {
                _results.push(ev);
              }
            }
            return _results;
          })();
          $scope.curr_evas_norm = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = evas.length; _i < _len; _i++) {
              eva = evas[_i];
              if (eva.ev.name !== 'linkchg') {
                _results.push(eva);
              }
            }
            return _results;
          })();
          $scope.link_evs = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = allevs.length; _i < _len; _i++) {
              ev = allevs[_i];
              if (ev.name === 'linkchg') {
                _results.push(ev);
              }
            }
            return _results;
          })();
          $scope.curr_evas_link = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = evas.length; _i < _len; _i++) {
              eva = evas[_i];
              if (eva.ev.name === 'linkchg') {
                _results.push(eva);
              }
            }
            return _results;
          })();
          $scope.$apply();
          $('#normev_form select').chosen();
          $('#linkev_form select').chosen();
          $('#add_normev').trigger("chosen:updated");
          $('#add_linkev').trigger("chosen:updated");
          return $('#wait_spin').hide();
        };
        defev = {
          boot: [
            {
              actions: [
                {
                  name: 'local'
                }, {
                  name: 'remote'
                }, {
                  name: 'sms'
                }, {
                  name: 'smtp'
                }, {
                  name: 'snmp'
                }
              ]
            }
          ]
        };
        ({
          auth: [
            {
              status: 'fail',
              actions: [
                {
                  name: 'local'
                }, {
                  name: 'remote'
                }, {
                  name: 'sms'
                }, {
                  name: 'smtp'
                }, {
                  name: 'snmp'
                }, {
                  name: 'dout',
                  no: 1
                }
              ]
            }
          ],
          linkchg: [
            {
              no: 1,
              status: 'up',
              actions: [
                {
                  name: 'local'
                }, {
                  name: 'remote'
                }, {
                  name: 'dout',
                  no: 2
                }
              ]
            }, {
              no: 2,
              status: 'down',
              actions: [
                {
                  name: 'local'
                }, {
                  name: 'remote'
                }
              ]
            }
          ],
          power: [
            {
              no: 1,
              status: 'on',
              actions: [
                {
                  name: 'local'
                }, {
                  name: 'remote'
                }
              ]
            }, {
              no: 2,
              status: 'off',
              actions: [
                {
                  name: 'local'
                }, {
                  name: 'remote'
                }
              ]
            }
          ],
          di: [
            {
              no: 1,
              actions: [
                {
                  name: 'local'
                }, {
                  name: 'remote'
                }
              ]
            }, {
              no: 2,
              actions: [
                {
                  name: 'local'
                }, {
                  name: 'remote'
                }
              ]
            }
          ]
        });
        eventtab_register_funcs($scope);
        smith.emit('port_ctrl::get_status', function(cfg) {
          var agent;
          nports = cfg;
          agent = this;
          compare.pushdata(agent, 'evlevactmap', cfg);
          return compare.compare(agent, 'evlevactmap');
        });
        return smith.emit('evact_manager::get_event_cfg', function(cfg) {
          var agent;
          eventtab_load_cfg($scope, cfg);
          agent = this;
          compare.pushdata(agent, 'evlevactmap', cfg);
          return compare.compare(agent, 'evlevactmap');
        });
      }
    };
  });

  ngapp.directive('timentp', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/sys_time.html',
      scope: {},
      controller: function($rootScope, $scope, smith, data, msgbox, compare, $timeout) {
        var dp, localtime2date;
        compare.init();
        $('#dp1').datepicker('autoclose', true);
        dp = $('#dp1').data('datepicker');
        $scope.full_zonename = function() {
          var cities, city, conti, _ref;
          city = this.cfg.timezone;
          _ref = this.contis;
          for (conti in _ref) {
            cities = _ref[conti];
            if (__indexOf.call(cities, city) >= 0) {
              return "" + conti + "/" + city;
            }
          }
        };
        $scope.doapply = function() {
          var d, localtime, newcfg;
          d = dp.getDate();
          localtime = {
            fullyear: d.getFullYear(),
            month: d.getMonth(),
            date: d.getDate(),
            hours: d.getHours(),
            minutes: d.getMinutes(),
            seconds: d.getSeconds()
          };
          newcfg = {
            timesrc: this.cfg.timesrc,
            TZ: this.full_zonename(),
            ntp_server: this.cfg.ntp_server,
            localtime: localtime
          };
          smith.emit('system::set_time_cfg', newcfg);
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 1000);
        };
        $scope.srccaps = {
          manual: 'Manual',
          ntp: 'SNTP'
        };
        $scope.localtimecap = function() {
          var d;
          d = dp.getDate();
          return d.toLocaleString();
        };
        $scope.syncbrowser = function() {
          return dp.setDate(new Date());
        };
        setTimeout((function() {
          $('#zonesel').chosen({
            no_results_text: "No results match",
            max_selected_options: 1,
            width: "160px"
          });
          return $("#clock_source").chosen({
            disable_search: true,
            max_selected_options: 1,
            width: "160px"
          });
        }), 700);
        $.getJSON('assets/conti_zones.json', function(contis) {
          $scope.contis = contis;
          return $scope.$apply();
        });
        localtime2date = function(lt) {
          return new Date(lt.fullyear, lt.month, lt.date, lt.hours, lt.minutes, lt.seconds);
        };
        return smith.emit('system::get_time_cfg', function(cfg) {
          var agent;
          if (cfg.TZ == null) {
            cfg.TZ = 'Asia/Taipei';
          }
          cfg.timezone = cfg.TZ.split('/').slice(1).join('/');
          $scope.cfg = cfg;
          $scope.$apply();
          dp.setDate(localtime2date($scope.cfg.localtime));
          setTimeout((function() {
            return $('#zonesel').trigger("chosen:updated");
          }), 500);
          agent = this;
          compare.pushdata(agent, 'timentp', cfg);
          return compare.compare(agent, 'timentp');
        });
      }
    };
  });

  ngapp.directive('igmp', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/igmp_conf.html',
      scope: {},
      controller: function($scope, smith, msgbox, compare, $timeout) {
        compare.init();
        $scope.igmpg = {};
        $scope.old = {};
        smith.emit('igmp::get_sys_cfg', function(sys) {
          var agent;
          $scope.igmpg.sys = sys;
          agent = this;
          compare.pushdata(agent, 'igmp', sys);
          return compare.compare(agent, 'igmp');
        });
        smith.emit('igmp::get_ports_cfg', function(ports) {
          var agent;
          $scope.igmpg.ports = ports;
          agent = this;
          compare.pushdata(agent, 'igmp', ports);
          return compare.compare(agent, 'igmp');
        });
        smith.emit('igmp::get_entry_igmp_cfg', function(vlans) {
          var agent;
          $scope.igmpg.vlans = vlans;
          $scope.old = angular.copy($scope.igmpg);
          $scope.$apply();
          agent = this;
          compare.pushdata(agent, 'igmp', vlans);
          return compare.compare(agent, 'igmp');
        });
        return $scope.doapply = function() {
          smith.emit('igmp::set_sys_cfg', $scope.igmpg.sys);
          smith.emit('igmp::set_ports_cfg', $scope.igmpg.ports);
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 1000);
        };
      }
    };
  });

  ngapp.directive('localconf', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/systemlog_local_conf.html',
      scope: {},
      controller: function($scope, smith, msgbox, compare, $timeout) {
        compare.init();
        $scope.dosave = function() {
          smith.emit('evact_manager::set_local_cfg', $scope.cfg);
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 1000);
        };
        return smith.emit('evact_manager::get_local_cfg', function(cfg) {
          var agent;
          $scope.cfg = cfg;
          $scope.$apply();
          agent = this;
          compare.pushdata(agent, 'localconf', cfg);
          return compare.compare(agent, 'localconf');
        });
      }
    };
  });

  ngapp.directive('rsyslogconf', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/systemlog_rsyslog_conf.html',
      scope: {},
      controller: function($scope, smith, msgbox, compare, $timeout) {
        compare.init();
        $scope.dosave = function() {
          smith.emit('evact_manager::set_remote_cfg', $scope.rsyslog);
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 1000);
        };
        return smith.emit('evact_manager::get_remote_cfg', function(cfg) {
          var agent;
          $scope.rsyslog = cfg;
          $scope.$apply();
          agent = this;
          compare.pushdata(agent, 'rsyslogconf', cfg);
          return compare.compare(agent, 'rsyslogconf');
        });
      }
    };
  });

  ngapp.directive('sysinfo', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/sys_info.html',
      controller: function($scope, smith, msgbox, compare, $timeout) {
        compare.init();
        $scope.doapply = function() {
          smith.emit('system::set_sys_cfg', $scope.cfg);
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 1000);
        };
        return smith.emit('system::get_sys_cfg', function(cfg) {
          var agent;
          cfg = _.pick(cfg, 'name', 'description', 'location', 'contact');
          $scope.cfg = cfg;
          $scope.$apply();
          agent = this;
          compare.pushdata(agent, 'sysinfo', cfg);
          return compare.compare(agent, 'sysinfo');
        });
      }
    };
  });

  ngapp.directive('savecfg', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/system_savecfg.html',
      scope: {},
      controller: function($scope, smith, msgbox, $timeout) {
        d3.selectAll('.lstext').classed('apply_fail', false);
        d3.selectAll('.lstext').classed('same', false);
        d3.selectAll('.lstext').classed('host', false);
        d3.selectAll('.lstext').classed('diff', false);
        return $scope.dosave = function() {
          smith.emit('system::all_save_cfg');
          $scope.applying = true;
          return $timeout((function() {
            return $scope.applying = false;
          }), 3000);
        };
      }
    };
  });

  ngapp.directive('cfgexport', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/cfgexport.html',
      scope: {},
      controller: function($scope, smith, msgbox, $timeout) {
        var content, key, _fn, _ref;
        d3.selectAll('.lstext').classed('apply_fail', false);
        d3.selectAll('.lstext').classed('same', false);
        d3.selectAll('.lstext').classed('host', false);
        d3.selectAll('.lstext').classed('diff', false);
        $scope.ips = [];
        _ref = window.mr.network_devices_list();
        _fn = function(content) {
          var device, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = content.length; _i < _len; _i++) {
            device = content[_i];
            _results.push((function(device) {
              console.log(key);
              console.log(content);
              console.log(device);
              if (device.family === 'IPv4') {
                $scope.ips.push(device.address);
                $scope.ip = $scope.ips[0];
                if ($scope.ips.length > 1) {
                  return $scope.muti_ip = true;
                }
              }
            })(device));
          }
          return _results;
        };
        for (key in _ref) {
          content = _ref[key];
          _fn(content);
        }
        $scope.portn = 7000;
        $scope["export"] = function() {
          $scope.export_sucessed_ips = [];
          $scope.export_failed_ips = [];
          $scope.exporting = true;
          window.tftp.stop();
          setTimeout((function() {
            var when_done, when_error, when_start;
            when_start = function(m) {
              return console.log('client upload start!');
            };
            when_done = function(m) {
              msgbox.msgbar_show('export complete.', 'success');
              $scope.export_sucessed_ips.push(m.stats.remoteAddress);
              $scope.exporting = false;
              return $scope.$apply();
            };
            when_error = function(m) {
              msgbox.msgbar_show('export error.', 'error');
              $scope.export_failed_ips.push(m.stats.remoteAddress);
              return $scope.exporting = false;
            };
            return window.tftp.start($scope.ip, $scope.portn, $scope.exportpath, when_start, when_done, when_error);
          }), 100);
          return setTimeout((function() {
            var agent, _i, _len, _ref1, _results;
            _ref1 = window.agent;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              agent = _ref1[_i];
              _results.push((function(agent) {
                var exportcfg, msg, remoteip;
                if (agent.transport != null) {
                  remoteip = agent.transport.input.remoteAddress;
                  exportcfg = {
                    url: "tftp://" + $scope.ip + ":" + $scope.portn + "/" + remoteip + ".yml",
                    action: 'export'
                  };
                  msg = ['system::config_access', exportcfg];
                  return agent.send(msg);
                } else {

                }
              })(agent));
            }
            return _results;
          }), 300);
        };
        return $scope["import"] = function() {
          $scope.import_sucessed_ips = [];
          $scope.import_failed_ips = [];
          $scope.importing = true;
          window.tftp.stop();
          setTimeout((function() {
            return window.tftp.start($scope.ip, $scope.portn, $scope.importpath);
          }), 100);
          return setTimeout((function() {
            var agent, _i, _len, _ref1, _results;
            _ref1 = window.agent;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              agent = _ref1[_i];
              _results.push((function(agent) {
                var callback, importcfg, msg, remoteip;
                if (agent.transport != null) {
                  remoteip = agent.transport.input.remoteAddress;
                  importcfg = {
                    url: "tftp://" + $scope.ip + ":" + $scope.portn + "/" + remoteip + ".yml",
                    action: 'import'
                  };
                  callback = function(t) {
                    $scope.importing = false;
                    agent = this;
                    console.log(t);
                    if (t.state === true) {
                      msgbox.msgbar_show('import complete.', 'success');
                      if (agent.transport.input.remoteAddress != null) {
                        $scope.import_sucessed_ips.push(agent.transport.input.remoteAddress);
                        $scope.$apply();
                      }
                    }
                    if (t.state === false) {
                      console.log(t.err);
                      msgbox.msgbar_show('import error.', 'error');
                      if (agent.transport.input.remoteAddress != null) {
                        $scope.import_failed_ips.push(agent.transport.input.remoteAddress);
                        return $scope.$apply();
                      }
                    }
                  };
                  msg = ['system::config_access', importcfg, callback];
                  return agent.send(msg);
                } else {

                }
              })(agent));
            }
            return _results;
          }), 300);
        };
      }
    };
  });

  ngapp.directive('firmware', function() {
    return {
      restrict: 'E',
      templateUrl: 'pages/configs/firmware.html',
      scope: {},
      controller: function($scope, smith, msgbox, $timeout) {
        var content, key, _fn, _ref;
        d3.selectAll('.lstext').classed('apply_fail', false);
        d3.selectAll('.lstext').classed('same', false);
        d3.selectAll('.lstext').classed('host', false);
        d3.selectAll('.lstext').classed('diff', false);
        $scope.ips = [];
        _ref = window.mr.network_devices_list();
        _fn = function(content) {
          var device, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = content.length; _i < _len; _i++) {
            device = content[_i];
            _results.push((function(device) {
              if (device.family === 'IPv4') {
                $scope.ips.push(device.address);
                $scope.ip = $scope.ips[0];
                if ($scope.ips.length > 1) {
                  $scope.muti_ip = true;
                  return $scope.ip = $scope.ips[1];
                }
              }
            })(device));
          }
          return _results;
        };
        for (key in _ref) {
          content = _ref[key];
          _fn(content);
        }
        $scope.portn = 8081;
        $scope.$watch('firmwarepath', function(n, o) {
          var extension;
          if (n !== void 0) {
            extension = n.replace(n.slice(0, n.lastIndexOf('.')), '');
            if (extension === '.upg') {
              return console.log('good file');
            } else {
              return msgbox.msgbar_show('please select the .upg file', 'error');
            }
          }
        });
        return $scope.upgrade = function() {
          var up_path;
          $scope.sucessed_ips = [];
          $scope.failed_ips = [];
          $scope.upgrade_failed = false;
          up_path = $scope.firmwarepath.slice(0, $scope.firmwarepath.lastIndexOf('/'));
          $scope.remote_path = $scope.firmwarepath.replace(up_path, "http://" + $scope.ip + ":" + $scope.portn);
          if ($scope.remote_path !== void 0) {
            $scope.upgrading = true;
            window.fileserver.stop();
            setTimeout((function() {
              return window.fileserver.start($scope.portn, up_path);
            }), 100);
            return $timeout((function() {
              return smith.emit('system::upgrade', $scope.remote_path, function(r) {
                var agent;
                $scope.upgrading = false;
                console.log($scope.remote_path);
                agent = this;
                if (r.success === true) {
                  msgbox.msgbar_show(r.status, 'success');
                  $scope.upgrade_success = true;
                  $timeout((function() {
                    return $scope.upgrade_success = false;
                  }), 200000);
                  if (agent.transport.input.remoteAddress != null) {
                    $scope.sucessed_ips.push(agent.transport.input.remoteAddress);
                    $scope.$apply();
                  }
                }
                if (r.err != null) {
                  console.log(r.err);
                  msgbox.msgbar_show('Upgrade error.', 'error');
                  if (agent.transport.input.remoteAddress != null) {
                    $scope.failed_ips.push(agent.transport.input.remoteAddress);
                    $scope.upgrade_failed = true;
                    console.log($scope.failed_ips);
                    $scope.$apply();
                  }
                }
                return console.log(r);
              });
            }), 5000);
          }
        };
      }
    };
  });

  ngapp.constant('buttonConfig', {
    activeClass: 'active'
  });

  ngapp.directive("btnCheckbox", [
    "buttonConfig", function(buttonConfig) {
      var activeClass;
      activeClass = buttonConfig.activeClass || "active";
      return {
        require: "ngModel",
        link: function(scope, element, attrs, ngModelCtrl) {
          var falseValue, trueValue;
          trueValue = scope.$eval(attrs.btnCheckboxTrue) || true;
          falseValue = scope.$eval(attrs.btnCheckboxTrue) || false;
          scope.$watch((function() {
            return ngModelCtrl.$modelValue;
          }), function(modelValue) {
            if (angular.equals(modelValue, trueValue)) {
              return element.addClass(activeClass);
            } else {
              return element.removeClass(activeClass);
            }
          });
          return element.bind("click", function() {
            return scope.$apply(function() {
              return ngModelCtrl.$setViewValue((element.hasClass(activeClass) ? falseValue : trueValue));
            });
          });
        }
      };
    }
  ]);

  ngapp.directive("btnRadio", [
    "buttonConfig", function(buttonConfig) {
      var activeClass;
      activeClass = buttonConfig.activeClass || "active";
      return {
        require: "ngModel",
        link: function(scope, element, attrs, ngModelCtrl) {
          var value;
          value = scope.$eval(attrs.btnRadio);
          scope.$watch((function() {
            return ngModelCtrl.$modelValue;
          }), function(modelValue) {
            if (angular.equals(modelValue, value)) {
              return element.addClass(activeClass);
            } else {
              return element.removeClass(activeClass);
            }
          });
          return element.bind("click", function() {
            if (!element.hasClass(activeClass)) {
              return scope.$apply(function() {
                return ngModelCtrl.$setViewValue(value);
              });
            }
          });
        }
      };
    }
  ]);

  ngapp.directive("inputFile", function() {
    return {
      require: "ngModel",
      restrict: 'E',
      replace: false,
      template: '<div class="form-group"><input type="file" name="uploader" style="display:none;"><button class="fake-uploader">Selet File</button></div>',
      link: function(scope, ele, attrs, ngModelCtrl) {
        var classes, muti, nwdirectory, value;
        muti = attrs.multiple;
        nwdirectory = attrs.nwdirectory;
        classes = attrs["class"];
        value = attrs.value;
        if (muti != null) {
          ele.find('input[type="file"]').attr('multiple', '');
        }
        if (nwdirectory != null) {
          ele.find('input[type="file"]').attr('nwdirectory', '');
        }
        if (value != null) {
          ele.find('.fake-uploader').text(value);
        }
        if (classes != null) {
          ele.find('.fake-uploader').addClass(classes);
          ele.removeClass(classes);
        }
        ele.find('.fake-uploader').click(function() {
          return ele.find('input[type="file"]').click();
        });
        return ele.find('input[type="file"]').bind('change', function() {
          var filepath;
          filepath = ele.find('input[type="file"]').val();
          return scope.$apply(function() {
            return ngModelCtrl.$setViewValue(filepath);
          });
        });
      }
    };
  });

  ngapp.directive('clsbool', function() {
    return function(scope, ele, attr) {
      var vname;
      vname = attr.clsbool;
      if (attr.clsbool.indexOf('.') < 0) {
        vname = "" + attr.clsbool + "." + ele[0].id;
      }
      ele.addClass(attr.offcls);
      return scope.$watch(vname, function(newVal, oldVal) {
        var ncls, pcls, _ref, _ref1;
        if (newVal === oldVal) {
          return;
        }
        if (newVal) {
          _ref = [attr.oncls, attr.offcls], ncls = _ref[0], pcls = _ref[1];
        } else {
          _ref1 = [attr.offcls, attr.oncls], ncls = _ref1[0], pcls = _ref1[1];
        }
        ele.removeClass(pcls);
        return ele.addClass(ncls);
      });
    };
  });

  ngapp.directive('digit', function() {
    return {
      restrict: 'A',
      link: function($scope, ele) {
        return ele.bind('keypress', function(e) {
          var c;
          c = String.fromCharCode(e.which);
          if (__indexOf.call("0123456789", c) < 0) {
            return false;
          }
        });
      }
    };
  });

  ngapp.directive('csvnum', function() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function($scope, ele, attrs, ctrl) {
        ctrl.$render = function() {
          var value;
          value = ctrl.$viewValue;
          return ele.val(value.join(','));
        };
        ctrl.$parsers.push(function(s) {
          var nums, vs;
          return nums = (function() {
            var _i, _len, _ref, _results;
            _ref = s.split(',');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              vs = _ref[_i];
              if (Number(vs)) {
                _results.push(Number(vs));
              }
            }
            return _results;
          })();
        });
        return ele.bind('keypress', function(e) {
          var c;
          c = String.fromCharCode(e.which);
          if (__indexOf.call("0123456789, ", c) < 0) {
            return false;
          }
        });
      }
    };
  });

  ngapp.directive('vldfmt', function() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function(scope, elm, attrs, ctrl) {
        var m, validateFn;
        m = attrs.vldfmt;
        validateFn = function(val) {
          var ctx, isValid;
          if (val) {
            ctx = {
              optional: function(ele) {
                return false;
              }
            };
            isValid = $.validator.methods[m].call(ctx, val);
          } else {
            isValid = true;
          }
          ctrl.$setValidity(m, isValid);
          if (isValid) {
            return val;
          } else {
            return void 0;
          }
        };
        ctrl.$formatters.push(validateFn);
        return ctrl.$parsers.push(validateFn);
      }
    };
  });

  ngapp.directive("ngBlur", function() {
    return {
      restrict: "A",
      require: "ngModel",
      scope: {},
      link: function(scope, el, attrs, ctrl) {
        el.on("focus", function() {
          return scope.$apply(function() {
            return ctrl.$blurred = false;
          });
        });
        return el.on("blur", function() {
          return scope.$apply(function() {
            return ctrl.$blurred = true;
          });
        });
      }
    };
  });

  gui.Window.get().show();

}).call(this);

/*
//@ sourceMappingURL=main.map
*/
