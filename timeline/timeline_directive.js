// Generated by CoffeeScript 1.9.3
(function() {
  angular.module("timeline", ['syslog']).directive("timeline", [
    '$window', '$interval', 'syslogService', '$timeout', function($window, $interval, syslogService, $timeout) {
      return {
        restrict: "E",
        templateUrl: "timeline/timeline_template.html",
        scope: {
          chartViewModel: "=chart"
        },
        compile: function(tele, attrs) {
          var link;
          link = function(scope, ele, attr) {
            var cb, get_data, now, oldchartViewModelData, oldsysdata, onlyonce, options, startTime, timeline, timelineWraper;
            cb = function(d) {
              var node;
              console.log('[Info] Show Live Syslog');
              node = scope.chartViewModel.findNodeByIP(d.hostip);
              if (node !== false) {
                $timeout(function() {
                  console.log('[Info] This is timeout.');
                  node.data.nodeWarning = false;
                  return node.data.nodeAlive = true;
                }, 3000);
                node.data.nodeWarning = true;
                node.data.nodeAlive = false;
                return scope.$apply();
              } else {
                return console.log("[Warning] Can not find the node by IP: " + d.ip);
              }
            };
            //syslogService.startSyslogService(cb);
            timelineWraper = $('.timeline')[0];
            timeline = new links.Timeline(timelineWraper);
            options = {
              width: "100%",
              height: "100%",
              zoomMax: 315360000000 * 0.25 / 2,
              cluster: true,
              eventMargin: 5,
              eventMarginAxis: 10,
              groupMinHeight: 13
            };
            timeline.setOptions(options);
            now = new $window.Date();
            startTime = new $window.Date();
            startTime.setHours(startTime.getHours() - 2);
            timeline.setVisibleChartRange(startTime, now);
            scope.range = {
              start: {
                time: startTime,
                date: startTime
              },
              end: {
                time: now,
                date: now
              }
            };
            oldsysdata = [];
            get_data = function() {
              var endTime, timeline_range;
              timeline_range = timeline.getVisibleChartRange();
              startTime = timeline_range.start;
              endTime = timeline_range.end;
              //return syslogService.selectSyslogByDatetime(startTime, endTime, function(syslogdata) {
              //  //var d, data, fn, i, len;
              //  //if (angular.equals(oldsysdata, syslogdata) === false) {
              //  //  oldsysdata = syslogdata;
              //  //  data = [];
              //  //  fn = function(d) {
              //  //    return data.push({
              //  //      start: new Date(d.edatetime),
              //  //      content: d.category + " is " + d.strvalue,
              //  //      group: d.category,
              //  //      hostip: d.hostip,
              //  //      hostname: d.hostname
              //  //    });
              //  //  };
              //  //  for (i = 0, len = syslogdata.length; i < len; i++) {
              //  //    d = syslogdata[i];
              //  //    fn(d);
              //  //  }
              //  //  return timeline.draw(data);
              //  //}
              //});
            };

            /*
            scope.$watch 'range', (o, n) ->
              if n
                timeline.setVisibleChartRange scope.range.start.time, scope.range.end.time
            
            , true
             */
            get_data();
            links.events.addListener(timeline, 'rangechanged', function() {
              get_data();
              return scope.$apply(function() {
                var timeline_range;
                timeline_range = timeline.getVisibleChartRange();
                scope.range.start.time = timeline_range.start;
                scope.range.start.date = timeline_range.start;
                scope.range.end.time = timeline_range.end;
                return scope.range.end.date = timeline_range.end;
              });
            });
            links.events.addListener(timeline, 'select', function() {
              if (timeline.getSelection().length !== 0) {
                scope.content = timeline.data[timeline.getSelection()[0].row];
                timeline.setCurrentTime(timeline.data[timeline.getSelection()[0].row].start);
                scope.currentTime = timeline.data[timeline.getSelection()[0].row].start;
                return scope.$apply();
              }
            });
            scope.playing = false;
            onlyonce = true;
            oldchartViewModelData = [];
            scope.$watch('chartViewModel.data', function(n, o) {
              if (n !== void 0 && onlyonce) {
                oldchartViewModelData = JSON.stringify(n);
                onlyonce = false;
                return console.log('viewModel init completed');
              }
            });
            return scope.play = function() {
              var allevent, event, eventinRange, fn, i, len, playbackend, playbackloop, playbackstart, playloop, playtime;
              scope.playing = true;
              playtime = 500;
              playbackstart = timeline.getVisibleChartRange().start.valueOf();
              playbackend = timeline.getVisibleChartRange().end.valueOf();
              if (scope.playmoment) {
                playbackstart = scope.playmoment;
              } else {
                scope.playmoment = timeline.getVisibleChartRange().start.valueOf();
              }
              scope.playbackstep = (timeline.getVisibleChartRange().end.valueOf() - timeline.getVisibleChartRange().start.valueOf()) / playtime;
              allevent = timeline.getData();
              eventinRange = [];
              fn = function(event) {
                var ref;
                if ((playbackstart < (ref = event.start.valueOf()) && ref < playbackend)) {
                  return eventinRange.push(event);
                }
              };
              for (i = 0, len = allevent.length; i < len; i++) {
                event = allevent[i];
                fn(event);
              }
              playbackloop = function() {
                var fn1, j, len1;
                scope.playmoment = scope.playmoment + scope.playbackstep;
                scope.currentTime = new Date(scope.playmoment);
                timeline.setCurrentTime(scope.currentTime);
                fn1 = function(event) {
                  var connectorindex, linkindex, max, maxlink, maxnode, min, minlink, minnode, nodeindex;
                  if ((event.start.valueOf() - scope.playmoment) > 0) {
                    if ((event.start.valueOf() - scope.playmoment) < scope.playbackstep) {
                      console.log(event);
                      maxnode = scope.chartViewModel.data.nodes.length - 1;
                      minnode = 0;
                      nodeindex = Math.floor(Math.random() * (maxnode - minnode + 1)) + minnode;
                      scope.chartViewModel.data.nodes[nodeindex].nodeAlive = false;
                      maxlink = scope.chartViewModel.data.connections.length - 1;
                      minlink = 0;
                      linkindex = Math.floor(Math.random() * (maxlink - minlink + 1)) + minlink;
                      scope.chartViewModel.data.connections[linkindex].connectionNotBlocked = false;
                      max = scope.chartViewModel.data.nodes.length - 1;
                      min = 0;
                      nodeindex = Math.floor(Math.random() * (max - min + 1)) + min;
                      if (scope.chartViewModel.data.nodes[nodeindex].outputConnectors.length > 0) {
                        max = scope.chartViewModel.data.nodes[nodeindex].outputConnectors.length - 1;
                        connectorindex = Math.floor(Math.random() * (max - min + 1)) + min;
                        scope.chartViewModel.data.nodes[nodeindex].outputConnectors[connectorindex].linked = false;
                      }
                      if (scope.chartViewModel.data.nodes[nodeindex].inputConnectors.length > 0) {
                        max = scope.chartViewModel.data.nodes[nodeindex].inputConnectors.length - 1;
                        connectorindex = Math.floor(Math.random() * (max - min + 1)) + min;
                        return scope.chartViewModel.data.nodes[nodeindex].inputConnectors[connectorindex].linked = false;
                      }
                    }
                  }
                };
                for (j = 0, len1 = eventinRange.length; j < len1; j++) {
                  event = eventinRange[j];
                  fn1(event);
                }
                if (scope.playmoment > playbackend) {
                  console.log('end');
                  $interval.cancel(playloop);
                  scope.playing = false;
                  return scope.playmoment = timeline.getVisibleChartRange().start.valueOf();
                }
              };
              playloop = $interval(playbackloop, 1);
              scope.pause = function() {
                $interval.cancel(playloop);
                scope.playing = false;
                return scope.pause = true;
              };
              scope.reset = function() {
                var connection, connetor, j, k, l, len1, len2, len3, len4, m, node, ref, ref1, ref2, ref3, results;
                $interval.cancel(playloop);
                scope.playmoment = timeline.getVisibleChartRange().start.valueOf();
                timeline.setCurrentTime(scope.playmoment);
                scope.playing = false;
                scope.pause = false;
                ref = scope.chartViewModel.data.nodes;
                for (j = 0, len1 = ref.length; j < len1; j++) {
                  node = ref[j];
                  node.nodeAlive = true;
                  ref1 = node.outputConnectors;
                  for (k = 0, len2 = ref1.length; k < len2; k++) {
                    connetor = ref1[k];
                    connetor.linked = true;
                  }
                  ref2 = node.inputConnectors;
                  for (l = 0, len3 = ref2.length; l < len3; l++) {
                    connetor = ref2[l];
                    connetor.linked = true;
                  }
                }
                ref3 = scope.chartViewModel.data.connections;
                results = [];
                for (m = 0, len4 = ref3.length; m < len4; m++) {
                  connection = ref3[m];
                  results.push(connection.connectionNotBlocked = true);
                }
                return results;
              };
              return scope.$on('$destroy', function() {
                return $interval.cancel(playloop);
              });
            };

            /*
            scope.playback = ->
              console.log 'start playback'
             */
          };
          return link;
        }
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=timeline_directive.js.map
